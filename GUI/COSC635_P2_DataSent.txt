21Network Working Group                                         W. Stevens
Request for Comments: 3542                                     M. Thomas
Obsoletes: 2292                                               Consultant
Category: Informational                                      E. Nordmark
                                                                     Sun
                                                               T. Jinmei
                                                                 Toshiba
                                                                May 2003




     Advanced Sockets Application Program Interface (API) for IPv6

Status of this Memo

   This memo provides information for the Internet community.  It does
   not specify an Internet standard of any kind.  Distribution of this
   memo is unlimited.

Copyright Not

   Copyright (C) The Internet Society (2003).  All Rights Reserved.

Abstract

   This document provides sockets Application Program Interface (API) to
   support "advanced" IPv6 applications, as a supplement to a separate
   specification, RFC 3493.  The expected applications include Ping,
   Traceroute, routing daemons and the like, which typically use raw
   sockets to access IPv6 or ICMPv6 header fields.  This document
   proposes some portable interfaces for applications that use raw
   sockets under IPv6.  There are other features of IPv6 that some
   applications will need to access: interface identification
   (specifying the outgoing interface and determining the incoming
   interface), IPv6 extension headers, and path Maximum Transmission
   Unit (MTU) information.  This document provides API access to these
   features too.  Additionally, some extended interfaces to libraries
   for the "r" commands are defined.  The extension will provide better
   backward compatibility to existing implementations that are not
   IPv6-capable.

bb













Stevens, et al.              Informational                      [Page 1]

RFC 3542             Advanced Sockets API for IPv6              May 2003


Table of Contents

   1.   Introduction ..............................................  3
   2.   Common Structures and Definitions .........................  5
        2.1  The ip6_hdr Structure ................................  6
             2.1.1  IPv6 Next Header Values .......................  6
             2.1.2  IPv6 Extension Headers ........................  7
             2.1.3  IPv6 Options ..................................  8
        2.2  The icmp6_hdr Structure .............................. 10
             2.2.1  ICMPv6 Type and Code Values ................... 10
             2.2.2  ICMPv6 Neighbor Discovery Definitions ......... 11
             2.2.3  Multicast Listener Discovery Definitions ...... 14
             2.2.4  ICMPv6 Router Renumbering Definitions ......... 14
        2.3  Address Testing Macros ............................... 16
        2.4  Protocols File ....................................... 16
   3.   IPv6 Raw Sockets .......................................... 17
        3.1  Checksums ............................................ 18
        3.2  ICMPv6 Type Filtering ................................ 19
        3.3  ICMPv6 Verification of Received Packets .............. 22
   4.   Access to IPv6 and Extension Headers ...................... 22
        4.1  TCP Implications ..................................... 24
        4.2  UDP and Raw Socket Implications ...................... 25
   5.   Extensions to Socket Ancillary Data ....................... 26
        5.1  CMSG_NXTHDR .......................................... 26
        5.2  CMSG_SPACE ........................................... 26
        5.3  CMSG_LEN ............................................. 27
   6.   Packet Information ........................................ 27
        6.1  Specifying/Receiving the Interface ................... 28
        6.2  Specifying/Receiving Source/Destination Address ...... 29
        6.3  Specifying/Receiving the Hop Limit ................... 29
        6.4  Specifying the Next Hop Address ...................... 30
        6.5  Specifying/Receiving the Traffic Class value ......... 31
        6.6  Additional Errors with sendmsg() and setsockopt() .... 32
        6.7  Summary of Outgoing Interface Selection .............. 32
   7.   Routing Header Option ..................................... 33
        7.1  inet6_rth_space ...................................... 35
        7.2  inet6_rth_init ....................................... 35
        7.3  inet6_rth_add ........................................ 36
        7.4  inet6_rth_reverse .................................... 36
        7.5  inet6_rth_segments ................................... 36
        7.6  inet6_rth_getaddr .................................... 36
   8.   Hop-By-Hop Options ........................................ 37
        8.1  Receiving Hop-by-Hop Options ......................... 38
        8.2  Sending Hop-by-Hop Options ........................... 38
   9.   Destination Options ....................................... 39
        9.1  Receiving Destination Options ........................ 39
        9.2  Sending Destination Options .......................... 39
   10.  Hop-by-Hop and Destination Options Processing ............. 40



Stevens, et al.              Informational                      [Page 2]

RFC 3542             Advanced Sockets API for IPv6              May 2003


        10.1  inet6_opt_init ...................................... 41
        10.2  inet6_opt_append .................................... 41
        10.3  inet6_opt_finish .................................... 42
        10.4  inet6_opt_set_val ................................... 42
        10.5  inet6_opt_next ...................................... 42
        10.6  inet6_opt_find ...................................... 43
        10.7  inet6_opt_get_val ................................... 43
   11.  Additional Advanced API Functions ......................... 44
        11.1  Sending with the Minimum MTU ........................ 44
        11.2  Sending without Fragmentation ....................... 45
        11.3  Path MTU Discovery and UDP .......................... 46
        11.4  Determining the Current Path MTU .................... 47
   12.  Ordering of Ancillary Data and IPv6 Extension Headers ..... 48
   13.  IPv6-Specific Options with IPv4-Mapped IPv6 Addresses ..... 50
   14.  Extended interfaces for rresvport, rcmd and rexec ......... 51
        14.1  rresvport_af ........................................ 51
        14.2  rcmd_af ............................................. 51
        14.3  rexec_af ............................................ 52
   15.  Summary of New Definitions ................................ 52
   16.  Security Considerations ................................... 56
   17.  Changes from RFC 2292 ..................................... 57
   18.  References ................................................ 59
   19.  Acknowledgments ........................................... 59
   20.  Appendix A: Ancillary Data Overview ....................... 60
        20.1  The msghdr Structure ................................ 60
        20.2  The cmsghdr Structure ............................... 61
        20.3  Ancillary Data Object Macros ........................ 62
              20.3.1  CMSG_FIRSTHDR ............................... 63
              20.3.2  CMSG_NXTHDR ................................. 64
              20.3.3  CMSG_DATA ................................... 65
              20.3.4  CMSG_SPACE .................................. 65
              20.3.5  CMSG_LEN .................................... 65
   21.  Appendix B: Examples Using the inet6_rth_XXX() Functions .. 65
        21.1  Sending a Routing Header ............................ 65
        21.2  Receiving Routing Headers ........................... 70
   22.  Appendix C: Examples Using the inet6_opt_XXX() Functions .. 72
        22.1  Building Options .................................... 72
        22.2  Parsing Received Options ............................ 74
   23.  Authors' Addresses ........................................ 76
   24.  Full Copyright Statement .................................. 77

1.  Introduction

   A separate specification [RFC-3493] contains changes to the sockets
   API to support IP version 6.  Those changes are for TCP and UDP-based
   applications.  This document defines some of the "advanced" features
   of the sockets API that are required for applications to take
   advantage of additional features of IPv6.



Stevens, et al.              Informational                      [Page 3]

RFC 3542             Advanced Sockets API for IPv6              May 2003


   Today, the portability of applications using IPv4 raw sockets is
   quite high, but this is mainly because most IPv4 implementations
   started from a common base (the Berkeley source code) or at least
   started with the Berkeley header files.  This allows programs such as
   Ping and Traceroute, for example, to compile with minimal effort on
   many hosts that support the sockets API.  With IPv6, however, there
   is no common source code base that implementors are starting from,
   and the possibility for divergence at this level between different
   implementations is high.  To avoid a complete lack of portability
   amongst applications that use raw IPv6 sockets, some standardization
   is necessary.

   There are also features from the basic IPv6 specification that are
   not addressed in [RFC-3493]: sending and receiving Routing headers,
   Hop-by-Hop options, and Destination options, specifying the outgoing
   interface, being told of the receiving interface, and control of path
   MTU information.

   This document updates and replaces RFC 2292.  This revision is based
   on implementation experience of RFC 2292, as well as some additional
   extensions that have been found to be useful through the IPv6
   deployment.  Note, however, that further work on this document may
   still be needed.  Once the API specification becomes mature and is
   deployed among implementations, it may be formally standardized by a
   more appropriate body, such as has been done with the Basic API
   [RFC-3493].

   This document can be divided into the following main sections.

   1. Definitions of the basic constants and structures required for
      applications to use raw IPv6 sockets.  This includes structure
      definitions for the IPv6 and ICMPv6 headers and all associated
      constants (e.g., values for the Next Header field).

   2. Some basic semantic definitions for IPv6 raw sockets.  For
      example, a raw ICMPv4 socket requires the application to calculate
      and store the ICMPv4 header checksum.  But with IPv6 this would
      require the application to choose the source IPv6 address because
      the source address is part of the pseudo header that ICMPv6 now
      uses for its checksum computation.  It should be defined that with
      a raw ICMPv6 socket the kernel always calculates and stores the
      ICMPv6 header checksum.

   3. Packet information: how applications can obtain the received
      interface, destination address, and received hop limit, along with
      specifying these values on a per-packet basis.  There are a class
      of applications that need this capability and the technique should
      be portable.



Stevens, et al.              Informational                      [Page 4]

RFC 3542             Advanced Sockets API for IPv6              May 2003


   4. Access to the optional Routing header, Hop-by-Hop options, and
      Destination options extension headers.

   5. Additional features required for improved IPv6 application
      portability.

   The packet information along with access to the extension headers
   (Routing header, Hop-by-Hop options, and Destination options) are
   specified using the "ancillary data" fields that were added to the
   4.3BSD Reno sockets API in 1990.  The reason is that these ancillary
   data fields are part of the Posix standard [POSIX] and should
   therefore be adopted by most vendors.

   This document does not address application access to either the
   authentication header or the encapsulating security payload header.

   Many examples in this document omit error checking in favor of
   brevity and clarity.

   We note that some of the functions and socket options defined in this
   document may have error returns that are not defined in this
   document.  Some of these possible error returns will be recognized
   only as implementations proceed.

   Datatypes in this document follow the Posix format: intN_t means a
   signed integer of exactly N bits (e.g., int16_t) and uintN_t means an
   unsigned integer of exactly N bits (e.g., uint32_t).

   Note that we use the (unofficial) terminology ICMPv4, IGMPv4, and
   ARPv4 to avoid any confusion with the newer ICMPv6 protocol.

2.  Common Structures and Definitions

   Many advanced applications examine fields in the IPv6 header and set
   and examine fields in the various ICMPv6 headers.  Common structure
   definitions for these protocol headers are required, along with
   common constant definitions for the structure members.

   This API assumes that the fields in the protocol headers are left in
   the network byte order, which is big-endian for the Internet
   protocols.  If not, then either these constants or the fields being
   tested must be converted at run-time, using something like htons() or
   htonl().

   Two new header files are defined: <netinet/ip6.h> and
   <netinet/icmp6.h>.





Stevens, et al.              Informational                      [Page 5]

RFC 3542             Advanced Sockets API for IPv6              May 2003


   When an include file is specified, that include file is allowed to
   include other files that do the actual declaration or definition.

2.1.  The ip6_hdr Structure

   The following structure is defined as a result of including
   <netinet/ip6.h>.  Note that this is a new header.

      struct ip6_hdr {
        union {
          struct ip6_hdrctl {
            uint32_t ip6_un1_flow; /* 4 bits version, 8 bits TC, 20 bits
                                      flow-ID */
            uint16_t ip6_un1_plen; /* payload length */
            uint8_t  ip6_un1_nxt;  /* next header */
            uint8_t  ip6_un1_hlim; /* hop limit */
          } ip6_un1;
          uint8_t ip6_un2_vfc;     /* 4 bits version, top 4 bits
                                      tclass */
        } ip6_ctlun;
        struct in6_addr ip6_src;   /* source address */
        struct in6_addr ip6_dst;   /* destination address */
      };

      #define ip6_vfc   ip6_ctlun.ip6_un2_vfc
      #define ip6_flow  ip6_ctlun.ip6_un1.ip6_un1_flow
      #define ip6_plen  ip6_ctlun.ip6_un1.ip6_un1_plen
      #define ip6_nxt   ip6_ctlun.ip6_un1.ip6_un1_nxt
      #define ip6_hlim  ip6_ctlun.ip6_un1.ip6_un1_hlim
      #define ip6_hops  ip6_ctlun.ip6_un1.ip6_un1_hlim

2.1.1.  IPv6 Next Header Values

   IPv6 defines many new values for the Next Header field.  The
   following constants are defined as a result of including
   <netinet/in.h>.

      #define IPPROTO_HOPOPTS   0   /* IPv6 Hop-by-Hop options */
      #define IPPROTO_IPV6     41   /* IPv6 header */
      #define IPPROTO_ROUTING  43   /* IPv6 Routing header */
      #define IPPROTO_FRAGMENT 44   /* IPv6 fragment header */
      #define IPPROTO_ESP      50   /* encapsulating security payload */
      #define IPPROTO_AH       51   /* authentication header */
      #define IPPROTO_ICMPV6   58   /* ICMPv6 */
      #define IPPROTO_NONE     59   /* IPv6 no next header */
      #define IPPROTO_DSTOPTS  60   /* IPv6 Destination options */





Stevens, et al.              Informational                      [Page 6]

RFC 3542             Advanced Sockets API for IPv6              May 2003


   Berkeley-derived IPv4 implementations also define IPPROTO_IP to be 0.
   This should not be a problem since IPPROTO_IP is used only with IPv4
   sockets and IPPROTO_HOPOPTS only with IPv6 sockets.

2.1.2.  IPv6 Extension Headers

   Six extension headers are defined for IPv6.  We define structures for
   all except the Authentication header and Encapsulating Security
   Payload header, both of which are beyond the scope of this document.
   The following structures are defined as a result of including
   <netinet/ip6.h>.

      /* Hop-by-Hop options header */
      struct ip6_hbh {
        uint8_t  ip6h_nxt;        /* next header */
        uint8_t  ip6h_len;        /* length in units of 8 octets */
          /* followed by options */
      };

      /* Destination options header */
      struct ip6_dest {
        uint8_t  ip6d_nxt;        /* next header */
        uint8_t  ip6d_len;        /* length in units of 8 octets */
          /* followed by options */
      };

      /* Routing header */
      struct ip6_rthdr {
        uint8_t  ip6r_nxt;        /* next header */
        uint8_t  ip6r_len;        /* length in units of 8 octets */
        uint8_t  ip6r_type;       /* routing type */
        uint8_t  ip6r_segleft;    /* segments left */
          /* followed by routing type specific data */
      };

      /* Type 0 Routing header */
      struct ip6_rthdr0 {
        uint8_t  ip6r0_nxt;       /* next header */
        uint8_t  ip6r0_len;       /* length in units of 8 octets */
        uint8_t  ip6r0_type;      /* always zero */
        uint8_t  ip6r0_segleft;   /* segments left */
        uint32_t ip6r0_reserved;  /* reserved field */
          /* followed by up to 127 struct in6_addr */
      };







Stevens, et al.              Informational                      [Page 7]

RFC 3542             Advanced Sockets API for IPv6              May 2003


      /* Fragment header */
      struct ip6_frag {
        uint8_t   ip6f_nxt;       /* next header */
        uint8_t   ip6f_reserved;  /* reserved field */
        uint16_t  ip6f_offlg;     /* offset, reserved, and flag */
        uint32_t  ip6f_ident;     /* identification */
      };

      #if     BYTE_ORDER == BIG_ENDIAN
      #define IP6F_OFF_MASK       0xfff8  /* mask out offset from
                                             ip6f_offlg */
      #define IP6F_RESERVED_MASK  0x0006  /* reserved bits in
                                             ip6f_offlg */
      #define IP6F_MORE_FRAG      0x0001  /* more-fragments flag */
      #else   /* BYTE_ORDER == LITTLE_ENDIAN */
      #define IP6F_OFF_MASK       0xf8ff  /* mask out offset from
                                             ip6f_offlg */
      #define IP6F_RESERVED_MASK  0x0600  /* reserved bits in
                                             ip6f_offlg */
      #define IP6F_MORE_FRAG      0x0100  /* more-fragments flag */
      #endif




7.3.  inet6_rth_add

      int inet6_rth_add(void *bp, const struct in6_addr *addr);

   This function adds the IPv6 address pointed to by addr to the end of
   the Routing header being constructed.

   If successful, the segleft member of the Routing Header is updated to
   account for the new address in the Routing header and the return
   value of the function is 0.  Upon an error the return value of the
   function is -1.

7.4.  inet6_rth_reverse

      int inet6_rth_reverse(const void *in, void *out);

   This function takes a Routing header extension header (pointed to by
   the first argument) and writes a new Routing header that sends
   datagrams along the reverse of that route.  The function reverses the
   order of the addresses and sets the segleft member in the new Routing
   header to the number of segments.  Both arguments are allowed to
   point to the same buffer (that is, the reversal can occur in place).

   The return value of the function is 0 on success, or -1 upon an
   error.

7.5.  inet6_rth_segments

      int inet6_rth_segments(const void *bp);

   This function returns the number of segments (addresses) contained in
   the Routing header described by bp.  On success the return value is
   zero or greater.  The return value of the function is -1 upon an
   error.

7.6.  inet6_rth_getaddr

      struct in6_addr *inet6_rth_getaddr(const void *bp, int index);

   This function returns a pointer to the IPv6 address specified by
   index (which must have a value between 0 and one less than the value
   returned by inet6_rth_segments()) in the Routing header described by
   bp.  An application should first call inet6_rth_segments() to obtain
   the number of segments in the Routing header.

   Upon an error the return value of the function is NULL.





Stevens, et al.              Informational                     [Page 36]

RFC 3542             Advanced Sockets API for IPv6              May 2003


8.  Hop-By-Hop Options

   A variable number of Hop-by-Hop options can appear in a single Hop-
   by-Hop options header.  Each option in the header is TLV-encoded with
   a type, length, and value.  This IPv6 API defines seven functions
   that the application calls to build and examine a Hop-by_Hop options
   header, and the ability to use sticky options or ancillary data to
   communicate this information between the application and the kernel.
   This uses the IPV6_HOPOPTS for a Hop-by-Hop options header.

   Today several Hop-by-Hop options are defined for IPv6.  Two pad
   options, Pad1 and PadN, are for alignment purposes and are
   automatically inserted by the inet6_opt_XXX() routines and ignored by
   the inet6_opt_XXX() routines on the receive side.  This section of
   the API is therefore defined for other (and future) Hop-by-Hop
   options that an application may need to specify and receive.

   Four functions build an options header:

      inet6_opt_init()     - initialize buffer data for options header
      inet6_opt_append()   - add one TLV option to the options header
      inet6_opt_finish()   - finish adding TLV options to the options
                             header
      inet6_opt_set_val()  - add one component of the option content to
                             the option

      Three functions deal with a returned options header:

      inet6_opt_next()     - extract the next option from the options
                             header
      inet6_opt_find()     - extract an option of a specified type from
                             the header
      inet6_opt_get_val()  - retrieve one component of the option
                             content

   Individual Hop-by-Hop options (and Destination options, which are
   described in Section 9 and are very similar to the Hop-by-Hop
   options) may have specific alignment requirements.  For example, the
   4-byte Jumbo Payload length should appear on a 4-byte boundary, and
   IPv6 addresses are normally aligned on an 8-byte boundary.  These
   requirements and the terminology used with these options are
   discussed in Section 4.2 and Appendix B of [RFC-2460].  The alignment
   of first byte of each option is specified by two values, called x and
   y, written as "xn + y".  This states that the option must appear at
   an integer multiple of x bytes from the beginning of the options
   header (x can have the values 1, 2, 4, or 8), plus y bytes (y can
   have a value between 0 and 7, inclusive).  The Pad1 and PadN options
   are inserted as needed to maintain the required alignment.  The



Stevens, et al.              Informational                     [Page 37]

RFC 3542             Advanced Sockets API for IPv6              May 2003


   functions below need to know the alignment of the end of the option
   (which is always in the form "xn," where x can have the values 1, 2,
   4, or 8) and the total size of the data portion of the option.  These
   are passed as the "align" and "len" arguments to inet6_opt_append().

   Multiple Hop-by-Hop options must be specified by the application by
   placing them in a single extension header.

   Finally, we note that use of some Hop-by-Hop options or some
   Destination options, might require special privilege.  That is,
   normal applications (without special privilege) might be forbidden
   from setting certain options in outgoing packets, and might never see
   certain options in received packets.

8.1.  Receiving Hop-by-Hop Options

   To receive a Hop-by-Hop options header the application must enable
   the IPV6_RECVHOPOPTS socket option:

      int  on = 1;
      setsockopt(fd, IPPROTO_IPV6, IPV6_RECVHOPOPTS, &on, sizeof(on));

   When using ancillary data a Hop-by-hop options header is passed
   between the application and the kernel as follows: The cmsg_level
   member will be IPPROTO_IPV6 and the cmsg_type member will be
   IPV6_HOPOPTS.  These options are then processed by calling the
   inet6_opt_next(), inet6_opt_find(), and inet6_opt_get_val()
   functions, described in Section 10.

8.2.  Sending Hop-by-Hop Options

   To send a Hop-by-Hop options header, the application specifies the
   header either as ancillary data in a call to sendmsg() or using
   setsockopt().

   The application can remove any sticky Hop-by-Hop options header by
   calling setsockopt() for IPV6_HOPOPTS with a zero option length.

   All the Hop-by-Hop options must be specified by a single ancillary
   data object.  The cmsg_level member is set to IPPROTO_IPV6 and the
   cmsg_type member is set to IPV6_HOPOPTS.  The option is normally
   constructed using the inet6_opt_init(), inet6_opt_append(),
   inet6_opt_finish(), and inet6_opt_set_val() functions, described in
   Section 10.

   Additional errors may be possible from sendmsg() and setsockopt() if
   the specified option is in error.




Stevens, et al.              Informational                     [Page 38]

RFC 3542             Advanced Sockets API for IPv6              May 2003


9.  Destination Options

   A variable number of Destination options can appear in one or more
   Destination options headers.  As defined in [RFC-2460], a Destination
   options header appearing before a Routing header is processed by the
   first destination plus any subsequent destinations specified in the
   Routing header, while a Destination options header that is not
   followed by a Routing header is processed only by the final
   destination.  As with the Hop-by-Hop options, each option in a
   Destination options header is TLV-encoded with a type, length, and
   value.

9.1.  Receiving Destination Options

   To receive Destination options header the application must enable the
   IPV6_RECVDSTOPTS socket option:

      int  on = 1;
      setsockopt(fd, IPPROTO_IPV6, IPV6_RECVDSTOPTS, &on, sizeof(on));

   Each Destination options header is returned as one ancillary data
   object described by a cmsghdr structure with cmsg_level set to
   IPPROTO_IPV6 and cmsg_type set to IPV6_DSTOPTS.

   These options are then processed by calling the inet6_opt_next(),
   inet6_opt_find(), and inet6_opt_get_value() functions.

9.2.  Sending Destination Options

   To send a Destination options header, the application specifies it
   either as ancillary data in a call to sendmsg() or using
   setsockopt().

   The application can remove any sticky Destination options header by
   calling setsockopt() for IPV6_RTHDRDSTOPTS/IPV6_DSTOPTS with a zero
   option length.

   This API assumes the ordering about extension headers as described in
   [RFC-2460].  Thus, one set of Destination options can only appear
   before a Routing header, and one set can only appear after a Routing
   header (or in a packet with no Routing header).  Each set can consist
   of one or more options but each set is a single extension header.

   Today all destination options that an application may want to specify
   can be put after (or without) a Routing header.  Thus, applications
   should usually need IPV6_DSTOPTS only and should avoid using
   IPV6_RTHDRDSTOPTS whenever possible.




Stevens, et al.              Informational                     [Page 39]

RFC 3542             Advanced Sockets API for IPv6              May 2003


   When using ancillary data a Destination options header is passed
   between the application and the kernel as follows: The set preceding
   a Routing header are specified with the cmsg_level member set to
   IPPROTO_IPV6 and the cmsg_type member set to IPV6_RTHDRDSTOPTS.  Any
   setsockopt or ancillary data for IPV6_RTHDRDSTOPTS is silently
   ignored when sending packets unless a Routing header is also
   specified.  Note that the "Routing header" here means the one
   specified by this API.  Even when the kernel inserts a routing header
   in its internal routine (e.g., in a mobile IPv6 stack), the
   Destination options header specified by IPV6_RTHDRDSTOPTS will still
   be ignored unless the application explicitly specifies its own
   Routing header.

   The set of Destination options after a Routing header, which are also
   used when no Routing header is present, are specified with the
   cmsg_level member is set to IPPROTO_IPV6 and the cmsg_type member is
   set to IPV6_DSTOPTS.

   The Destination options are normally constructed using the
   inet6_opt_init(), inet6_opt_append(), inet6_opt_finish(), and
   inet6_opt_set_val() functions, described in Section 10.

   Additional errors may be possible from sendmsg() and setsockopt() if
   the specified option is in error.

10.  Hop-by-Hop and Destination Options Processing

   Building and parsing the Hop-by-Hop and Destination options is
   complicated for the reasons given earlier.  We therefore define a set
   of functions to help the application.  These functions assume the
   formatting rules specified in Appendix B in [RFC-2460] i.e., that the
   largest field is placed last in the option.

   The function prototypes for these functions are defined as a result
   of including <netinet/in.h>.

   The first 3 functions (init, append, and finish) are used both to
   calculate the needed buffer size for the options, and to actually
   encode the options once the application has allocated a buffer for
   the header.  In order to only calculate the size the application must
   pass a NULL extbuf and a zero extlen to those functions.










Stevens, et al.              Informational                     [Page 40]

RFC 3542             Advanced Sockets API for IPv6              May 2003


10.1.  inet6_opt_init

      int inet6_opt_init(void *extbuf, socklen_t extlen);

   This function returns the number of bytes needed for the empty
   extension header i.e., without any options.  If extbuf is not NULL it
   also initializes the extension header to have the correct length
   field.  In that case if the extlen value is not a positive (i.e.,
   non-zero) multiple of 8 the function fails and returns -1.

   (Note: since the return value on success is based on a "constant"
   parameter, i.e., the empty extension header, an implementation may
   return a constant value.  However, this specification does not
   require the value be constant, and leaves it as implementation
   dependent.  The application should not assume a particular constant
   value as a successful return value of this function.)

10.2.  inet6_opt_append

      int inet6_opt_append(void *extbuf, socklen_t extlen, int offset,
                           uint8_t type, socklen_t len, uint_t align,
                           void **databufp);

   Offset should be the length returned by inet6_opt_init() or a
   previous inet6_opt_append().  This function returns the updated total
   length taking into account adding an option with length 'len' and
   alignment 'align'.  If extbuf is not NULL then, in addition to
   returning the length, the function inserts any needed pad option,
   initializes the option (setting the type and length fields) and
   returns a pointer to the location for the option content in databufp.
   If the option does not fit in the extension header buffer the
   function returns -1.

   Type is the 8-bit option type.  Len is the length of the option data
   (i.e., excluding the option type and option length fields).

   Once inet6_opt_append() has been called the application can use the
   databuf directly, or use inet6_opt_set_val() to specify the content
   of the option.

   The option type must have a value from 2 to 255, inclusive.  (0 and 1
   are reserved for the Pad1 and PadN options, respectively.)

   The option data length must have a value between 0 and 255,
   inclusive, and is the length of the option data that follows.

   The align parameter must have a value of 1, 2, 4, or 8.  The align
   value can not exceed the value of len.



Stevens, et al.              Informational                     [Page 41]

RFC 3542             Advanced Sockets API for IPv6              May 2003


10.3.  inet6_opt_finish

      int inet6_opt_finish(void *extbuf, socklen_t extlen, int offset);

   Offset should be the length returned by inet6_opt_init() or
   inet6_opt_append().  This function returns the updated total length
   taking into account the final padding of the extension header to make
   it a multiple of 8 bytes.  If extbuf is not NULL the function also
   initializes the option by inserting a Pad1 or PadN option of the
   proper length.

   If the necessary pad does not fit in the extension header buffer the
   function returns -1.

10.4.  inet6_opt_set_val

      int inet6_opt_set_val(void *databuf, int offset, void *val,
                            socklen_t vallen);

   Databuf should be a pointer returned by inet6_opt_append().  This
   function inserts data items of various sizes in the data portion of
   the option.  Val should point to the data to be inserted.  Offset
   specifies where in the data portion of the option the value should be
   inserted; the first byte after the option type and length is accessed
   by specifying an offset of zero.

   The caller should ensure that each field is aligned on its natural
   boundaries as described in Appendix B of [RFC-2460], but the function
   must not rely on the caller's behavior.  Even when the alignment
   requirement is not satisfied, inet6_opt_set_val should just copy the
   data as required.

   The function returns the offset for the next field (i.e., offset +
   vallen) which can be used when composing option content with multiple
   fields.

10.5.  inet6_opt_next

      int inet6_opt_next(void *extbuf, socklen_t extlen, int offset,
                         uint8_t *typep, socklen_t *lenp,
                         void **databufp);

   This function parses received option extension headers returning the
   next option.  Extbuf and extlen specifies the extension header.
   Offset should either be zero (for the first option) or the length
   returned by a previous call to inet6_opt_next() or inet6_opt_find().
   It specifies the position where to continue scanning the extension
   buffer.  The next option is returned by updating typep, lenp, and



Stevens, et al.              Informational                     [Page 42]

RFC 3542             Advanced Sockets API for IPv6              May 2003


   databufp.  Typep stores the option type, lenp stores the length of
   the option data (i.e., excluding the option type and option length
   fields), and databufp points the data field of the option.  This
   function returns the updated "previous" length computed by advancing
   past the option that was returned.  This returned "previous" length
   can then be passed to subsequent calls to inet6_opt_next().  This
   function does not return any PAD1 or PADN options.  When there are no
   more options or if the option extension header is malformed the
   return value is -1.

10.6.  inet6_opt_find

      int inet6_opt_find(void *extbuf, socklen_t extlen, int offset,
                         uint8_t type, socklen_t *lenp,
                         void **databufp);

   This function is similar to the previously described inet6_opt_next()
   function, except this function lets the caller specify the option
   type to be searched for, instead of always returning the next option
   in the extension header.

   If an option of the specified type is located, the function returns
   the updated "previous" total length computed by advancing past the
   option that was returned and past any options that didn't match the
   type.  This returned "previous" length can then be passed to
   subsequent calls to inet6_opt_find() for finding the next occurrence
   of the same option type.

   If an option of the specified type is not located, the return value
   is -1.  If the option extension header is malformed, the return value
   is -1.

10.7.  inet6_opt_get_val

      int inet6_opt_get_val(void *databuf, int offset, void *val,
                            socklen_t vallen);

   Databuf should be a pointer returned by inet6_opt_next() or
   inet6_opt_find().  This function extracts data items of various sizes
   in the data portion of the option.  Val should point to the
   destination for the extracted data.  Offset specifies from where in
   the data portion of the option the value should be extracted; the
   first byte after the option type and length is accessed by specifying
   an offset of zero.

   It is expected that each field is aligned on its natural boundaries
   as described in Appendix B of [RFC-2460], but the function must not
   rely on the alignment.



Stevens, et al.              Informational                     [Page 43]

RFC 3542             Advanced Sockets API for IPv6              May 2003


   The function returns the offset for the next field (i.e., offset +
   vallen) which can be used when extracting option content with
   multiple fields.

11.  Additional Advanced API Functions

11.1.  Sending with the Minimum MTU

   Unicast applications should usually let the kernel perform path MTU
   discovery [RFC-1981], as long as the kernel supports it, and should
   not care about the path MTU.  Some applications, however, might not
   want to incur the overhead of path MTU discovery, especially if the
   applications only send a single datagram to a destination.  A
   potential example is a DNS server.

   [RFC-1981] describes how path MTU discovery works for multicast
   destinations.  From practice in using IPv4 multicast, however, many
   careless applications that send large multicast packets on the wire
   have caused implosion of ICMPv4 error messages.  The situation can be
   worse when there is a filtering node that blocks the ICMPv4 messages.
   Though the filtering issue applies to unicast as well, the impact is
   much larger in the multicast cases.

   Thus, applications sending multicast traffic should explicitly enable
   path MTU discovery only when they understand that the benefit of
   possibly larger MTU usage outweighs the possible impact of MTU
   discovery for active sources across the delivery tree(s).  This
   default behavior is based on the today's practice with IPv4 multicast
   and path MTU discovery.  The behavior may change in the future once
   it is found that path MTU discovery effectively works with actual
   multicast applications and network configurations.

   This specification defines a mechanism to avoid path MTU discovery by
   sending at the minimum IPv6 MTU [RFC-2460].  If the packet is larger
   than the minimum MTU and this feature has been enabled the IP layer
   will fragment to the minimum MTU.  To control the policy about path
   MTU discovery, applications can use the IPV6_USE_MIN_MTU socket
   option.

   As described above, the default policy should depend on whether the
   destination is unicast or multicast.  For unicast destinations path
   MTU discovery should be performed by default.  For multicast
   destinations path MTU discovery should be disabled by default.  This
   option thus takes the following three types of integer arguments:

   -1: perform path MTU discovery for unicast destinations but do not
       perform it for multicast destinations.  Packets to multicast
       destinations are therefore sent with the minimum MTU.



Stevens, et al.              Informational                     [Page 44]

RFC 3542             Advanced Sockets API for IPv6              May 2003


   0: always perform path MTU discovery.

   1: always disable path MTU discovery and send packets at the minimum
       MTU.

   The default value of this option is -1.  Values other than -1, 0, and
   1 are invalid, and an error EINVAL will be returned for those values.

   As an example, if a unicast application intentionally wants to
   disable path MTU discovery, it will add the following lines:

      int  on = 1;
      setsockopt(fd, IPPROTO_IPV6, IPV6_USE_MIN_MTU, &on, sizeof(on));

   Note that this API intentionally excludes the case where the
   application wants to perform path MTU discovery for multicast but to
   disable it for unicast.  This is because such usage is not feasible
   considering a scale of performance issues around whether to do path
   MTU discovery or not.  When path MTU discovery makes sense to a
   destination but not to a different destination, regardless of whether
   the destination is unicast or multicast, applications either need to
   toggle the option between sending such packets on the same socket, or
   use different sockets for the two classes of destinations.

   This option can also be sent as ancillary data.  In the cmsghdr
   structure containing this ancillary data, the cmsg_level member will
   be IPPROTO_IPV6, the cmsg_type member will be IPV6_USE_MIN_MTU, and
   the first byte of cmsg_data[] will be the first byte of the integer.

11.2.  Sending without Fragmentation

   In order to provide for easy porting of existing UDP and raw socket
   applications IPv6 implementations will, when originating packets,
   automatically insert a fragment header in the packet if the packet is
   too big for the path MTU.

   Some applications might not want this behavior.  An example is
   traceroute which might want to discover the actual path MTU.

   This specification defines a mechanism to turn off the automatic
   inserting of a fragment header for UDP and raw sockets.  This can be
   enabled using the IPV6_DONTFRAG socket option.

      int on = 1;
      setsockopt(fd, IPPROTO_IPV6, IPV6_DONTFRAG, &on, sizeof(on));






Stevens, et al.              Informational                     [Page 45]

RFC 3542             Advanced Sockets API for IPv6              May 2003


   By default, this socket option is disabled.  Setting the value to 0
   also disables the option i.e., reverts to the default behavior of
   automatic inserting.  This option can also be sent as ancillary data.
   In the cmsghdr structure containing this ancillary data, the
   cmsg_level member will be IPPROTO_IPV6, the cmsg_type member will be
   IPV6_DONTFRAG, and the first byte of cmsg_data[] will be the first
   byte of the integer.  This API only specifies the use of this option
   for UDP and raw sockets, and does not define the usage for TCP
   sockets.

   When the data size is larger than the MTU of the outgoing interface,
   the packet will be discarded.  Applications can know the result by
   enabling the IPV6_RECVPATHMTU option described below and receiving
   the corresponding ancillary data items.  An additional error EMSGSIZE
   may also be returned in some implementations.  Note, however, that
   some other implementations might not be able to return this
   additional error when sending a message.

11.3.  Path MTU Discovery and UDP

   UDP and raw socket applications need to be able to  determine the
   "maximum send transport-message size" (Section 5.1 of [RFC-1981]) to
   a given destination so that those applications can participate in
   path MTU discovery.  This lets those applications send smaller
   datagrams to the destination, avoiding fragmentation.

   This is accomplished using a new ancillary data item (IPV6_PATHMTU)
   which is delivered to recvmsg() without any actual data.  The
   application can enable the receipt of IPV6_PATHMTU ancillary data
   items by setting the IPV6_RECVPATHMTU socket option.

      int  on = 1;
      setsockopt(fd, IPPROTO_IPV6, IPV6_RECVPATHMTU, &on, sizeof(on));

   By default, this socket option is disabled.  Setting the value to 0
   also disables the option.  This API only specifies the use of this
   option for UDP and raw sockets, and does not define the usage for TCP
   sockets.

   When the application is sending packets too big for the path MTU
   recvmsg() will return zero (indicating no data) but there will be a
   cmsghdr with cmsg_type set to IPV6_PATHMTU, and cmsg_len will
   indicate that cmsg_data is sizeof(struct ip6_mtuinfo) bytes long.
   This can happen when the sending node receives a corresponding ICMPv6
   packet too big error, or when the packet is sent from a socket with
   the IPV6_DONTFRAG option being on and the packet size is larger than
   the MTU of the outgoing interface.  This indication is considered as
   an ancillary data item for a separate (empty) message.  Thus, when



Stevens, et al.              Informational                     [Page 46]

RFC 3542             Advanced Sockets API for IPv6              May 2003


   there are buffered messages (i.e., messages that the application has
   not received yet) on the socket the application will first receive
   the buffered messages and then receive the indication.

   The first byte of cmsg_data[] will point to a struct ip6_mtuinfo
   carrying the path MTU to use together with the IPv6 destination
   address.

      struct ip6_mtuinfo {
        struct sockaddr_in6 ip6m_addr; /* dst address including
                                          zone ID */
        uint32_t            ip6m_mtu;  /* path MTU in host byte order */
      };

   This cmsghdr will be passed to every socket that sets the
   IPV6_RECVPATHMTU socket option, even if the socket is non-connected.
   Note that this also means an application that sets the option may
   receive an IPV6_MTU ancillary data item for each ICMP too big error
   the node receives, including such ICMP errors caused by other
   applications on the node.  Thus, an application that wants to perform
   the path MTU discovery by itself needs to keep history of
   destinations that it has actually sent to and to compare the address
   returned in the ip6_mtuinfo structure to the history.  An
   implementation may choose not to delivery data to a connected socket
   that has a foreign address that is different than the address
   specified in the ip6m_addr structure.

   When an application sends a packet with a routing header, the final
   destination stored in the ip6m_addr member does not necessarily
   contain complete information of the entire path.

11.4.  Determining the Current Path MTU

   Some applications might need to determine the current path MTU e.g.,
   applications using IPV6_RECVPATHMTU might want to pick a good
   starting value.

   This specification defines a get-only socket option to retrieve the
   current path MTU value for the destination of a given connected
   socket.  If the IP layer does not have a cached path MTU value it
   will return the interface MTU for the interface that will be used
   when sending to the destination address.

   This information is retrieved using the IPV6_PATHMTU socket option.
   This option takes a pointer to the ip6_mtuinfo structure as the
   fourth argument, and the size of the structure should be passed as a
   value-result parameter in the fifth argument.




Stevens, et al.              Informational                     [Page 47]

RFC 3542             Advanced Sockets API for IPv6              May 2003


      struct ip6_mtuinfo mtuinfo;
      socklen_t infolen = sizeof(mtuinfo);

      getsockopt(fd, IPPROTO_IPV6, IPV6_PATHMTU, &mtuinfo, &infolen);

   When the call succeeds, the path MTU value is stored in the ip6m_mtu
   member of the ip6_mtuinfo structure.  Since the socket is connected,
   the ip6m_addr member is meaningless and should not be referred to by
   the application.

   This option can only be used for a connected socket, because a non-
   connected socket does not have the information of the destination and
   there is no way to pass the destination via getsockopt().  When
   getsockopt() for this option is issued on a non-connected socket, the
   call will fail.  Despite this limitation, this option is still useful
   from a practical point of view, because applications that care about
   the path MTU tend to send a lot of packets to a single destination
   and to connect the socket to the destination for performance reasons.
   If the application needs to get the MTU value in a more generic way,
   it should use a more generic interface, such as routing sockets
   [TCPIPILLUST].

12.  Ordering of Ancillary Data and IPv6 Extension Headers

   Three IPv6 extension headers can be specified by the application and
   returned to the application using ancillary data with sendmsg() and
   recvmsg(): the Routing header, Hop-by-Hop options header, and
   Destination options header.  When multiple ancillary data objects are
   transferred via recvmsg() and these objects represent any of these
   three extension headers, their placement in the control buffer is
   directly tied to their location in the corresponding IPv6 datagram.
   For example, when the application has enabled the IPV6_RECVRTHDR and
   IPV6_RECVDSTOPTS options and later receives an IPv6 packet with
   extension headers in the following order:

      The IPv6 header
      A Hop-by-Hop options header
      A Destination options header (1)
      A Routing header
      An Authentication header
      A Destination options header (2)
      A UDP header and UDP data









Stevens, et al.              Informational                     [Page 48]

RFC 3542             Advanced Sockets API for IPv6              May 2003


   then the application will receive three ancillary data objects in the
   following order:

      an object with cmsg_type set to IPV6_DSTOPTS, which represents
      the destination options header (1)
      an object with cmsg_type set to IPV6_RTHDR, which represents the
      Routing header
      an object with cmsg_type set to IPV6_DSTOPTS, which represents the
      destination options header (2)

   This example follows the header ordering described in [RFC-2460], but
   the receiving side of this specification does not assume the
   ordering.  Applications may receive any numbers of objects in any
   order according to the ordering of the received IPv6 datagram.

   For the sending side, however, this API imposes some ordering
   constraints according to [RFC-2460].  Applications using this API
   cannot make a packet with extension headers that do not follow the
   ordering.  Note, however, that this does not mean applications must
   always follow the restriction.  This is just a limitation in this API
   in order to give application programmers a guideline to construct
   headers in a practical manner.  Should an application need to make an
   outgoing packet in an arbitrary order about the extension headers,
   some other technique, such as the datalink interfaces BPF or DLPI,
   must be used.

   The followings are more details about the constraints:

   -  Each IPV6_xxx ancillary data object for a particular type of
      extension header can be specified at most once in a single control
      buffer.

   -  IPV6_xxx ancillary data objects can appear in any order in a
      control buffer, because there is no ambiguity of the ordering.

   -  Each set of IPV6_xxx ancillary data objects and sticky options
      will be put in the outgoing packet along with the header ordering
      described in [RFC-2460].

   -  An ancillary data object or a sticky option of IPV6_RTHDRDSTOPTS
      will affect the outgoing packet only when a Routing header is
      specified as an ancillary data object or a sticky option.
      Otherwise, the specified value for IPV6_RTHDRDSTOPTS will be
      ignored.







Stevens, et al.              Informational                     [Page 49]

RFC 3542             Advanced Sockets API for IPv6              May 2003


   For example, when an application sends a UDP datagram with a control
   data buffer containing ancillary data objects in the following order:

      an object with cmsg_type set to IPV6_DSTOPTS
      an object with cmsg_type set to IPV6_RTHDRDSTOPTS
      an object with cmsg_type set to IPV6_HOPOPTS

   and the sending socket does not have any sticky options, then the
   outgoing packet would be constructed as follows:

      The IPv6 header
      A Hop-by-Hop options header
      A Destination options header
      A UDP header and UDP data

   where the destination options header corresponds to the ancillary
   data object with the type IPV6_DSTOPTS.

   Note that the constraints above do not necessarily mean that the
   outgoing packet sent on the wire always follows the header ordering
   specified in this API document.  The kernel may insert additional
   headers that break the ordering as a result.  For example, if the
   kernel supports Mobile IPv6, an additional destination options header
   may be inserted before an authentication header, even without a
   routing header.

   This API does not provide access to any other extension headers than
   the supported three types of headers.  In particular, no information
   is provided about the IP security headers on an incoming packet, nor
   can be specified for an outgoing packet.  This API is for
   applications that do not care about the existence of IP security
   headers.

13.  IPv6-Specific Options with IPv4-Mapped IPv6 Addresses

   The various socket options and ancillary data specifications defined
   in this document apply only to true IPv6 sockets.  It is possible to
   create an IPv6 socket that actually sends and receives IPv4 packets,
   using IPv4-mapped IPv6 addresses, but the mapping of the options
   defined in this document to an IPv4 datagram is beyond the scope of
   this document.

   In general, attempting to specify an IPv6-only option, such as the
   Hop-by-Hop options, Destination options, or Routing header on an IPv6
   socket that is using IPv4-mapped IPv6 addresses, will probably result
   in an error.  Some implementations, however, may provide access to





Stevens, et al.              Informational                     [Page 50]

RFC 3542             Advanced Sockets API for IPv6              May 2003


   the packet information (source/destination address, send/receive
   interface, and hop limit) on an IPv6 socket that is using IPv4-mapped
   IPv6 addresses.

14.  Extended interfaces for rresvport, rcmd and rexec

   Library functions that support the "r" commands hide the creation of
   a socket and the name resolution procedure from an application.  When
   the libraries return an AF_INET6 socket to an application that do not
   support the address family, the application may encounter an
   unexpected result when, e.g., calling getpeername() for the socket.
   In order to support AF_INET6 sockets for the "r" commands while
   keeping backward compatibility, this section defines some extensions
   to the libraries.

14.1.  rresvport_af

   The rresvport() function is used by the rcmd() function, and this
   function is in turn called by many of the "r" commands such as
   rlogin.  While new applications are not being written to use the
   rcmd() function, legacy applications such as rlogin will continue to
   use it and these will be ported to IPv6.

   rresvport() creates an IPv4/TCP socket and binds a "reserved port" to
   the socket.  Instead of defining an IPv6 version of this function we
   define a new function that takes an address family as its argument.

      #include <unistd.h>

      int  rresvport_af(int *port, int family);

   This function behaves the same as the existing rresvport() function,
   but instead of creating an AF_INET TCP socket, it can also create an
   AF_INET6 TCP socket.  The family argument is either AF_INET or
   AF_INET6, and a new error return is EAFNOSUPPORT if the address
   family is not supported.

   (Note: There is little consensus on which header defines the
   rresvport() and rcmd() function prototypes.  4.4BSD defines it in
   <unistd.h>, others in <netdb.h>, and others don't define the function
   prototypes at all.)

14.2.  rcmd_af

   The existing rcmd() function can not transparently use AF_INET6
   sockets since an application would not be prepared to handle AF_INET6
   addresses returned by e.g., getpeername() on the file descriptor
   created by rcmd().  Thus a new function is needed.



Stevens, et al.              Informational                     [Page 51]

RFC 3542             Advanced Sockets API for IPv6              May 2003


      int rcmd_af(char **ahost, unsigned short rport,
                  const char *locuser, const char *remuser,
                  const char *cmd, int *fd2p, int af)

   This function behaves the same as the existing rcmd() function, but
   instead of creating an AF_INET TCP socket, it can also create an
   AF_INET6 TCP socket.  The family argument is AF_INET, AF_INET6, or
   AF_UNSPEC.  When either AF_INET or AF_INET6 is specified, this
   function will create a socket of the specified address family.  When
   AF_UNSPEC is specified, it will try all possible address families
   until a connection can be established, and will return the associated
   socket of the connection.  A new error EAFNOSUPPORT will be returned
   if the address family is not supported.

14.3.  rexec_af

   The existing rexec() function can not transparently use AF_INET6
   sockets since an application would not be prepared to handle AF_INET6
   addresses returned by e.g., getpeername() on the file descriptor
   created by rexec().  Thus a new function is needed.

      int rexec_af(char **ahost, unsigned short rport, const char *name,
                   const char *pass, const char *cmd, int *fd2p, int af)

   This function behaves the same as the existing rexec() function, but
   instead of creating an AF_INET TCP socket, it can also create an
   AF_INET6 TCP socket.  The family argument is AF_INET, AF_INET6, or
   AF_UNSPEC.  When either AF_INET or AF_INET6 is specified, this
   function will create a socket of the specified address family.  When
   AF_UNSPEC is specified, it will try all possible address families
   until a connection can be established, and will return the associated
   socket of the connection.  A new error EAFNOSUPPORT will be returned
   if the address family is not supported.

15.  Summary of New Definitions

   The following list summarizes the constants and structure,
   definitions discussed in this memo, sorted by header.

      <netinet/icmp6.h> ICMP6_DST_UNREACH
      <netinet/icmp6.h> ICMP6_DST_UNREACH_ADDR
      <netinet/icmp6.h> ICMP6_DST_UNREACH_ADMIN
      <netinet/icmp6.h> ICMP6_DST_UNREACH_BEYONDSCOPE
      <netinet/icmp6.h> ICMP6_DST_UNREACH_NOPORT
      <netinet/icmp6.h> ICMP6_DST_UNREACH_NOROUTE
      <netinet/icmp6.h> ICMP6_ECHO_REPLY
      <netinet/icmp6.h> ICMP6_ECHO_REQUEST
      <netinet/icmp6.h> ICMP6_INFOMSG_MASK



Stevens, et al.              Informational                     [Page 52]

RFC 3542             Advanced Sockets API for IPv6              May 2003


      <netinet/icmp6.h> ICMP6_PACKET_TOO_BIG
      <netinet/icmp6.h> ICMP6_PARAMPROB_HEADER
      <netinet/icmp6.h> ICMP6_PARAMPROB_NEXTHEADER
      <netinet/icmp6.h> ICMP6_PARAMPROB_OPTION
      <netinet/icmp6.h> ICMP6_PARAM_PROB
      <netinet/icmp6.h> ICMP6_ROUTER_RENUMBERING
      <netinet/icmp6.h> ICMP6_RR_FLAGS_FORCEAPPLY
      <netinet/icmp6.h> ICMP6_RR_FLAGS_PREVDONE
      <netinet/icmp6.h> ICMP6_RR_FLAGS_REQRESULT
      <netinet/icmp6.h> ICMP6_RR_FLAGS_SPECSITE
      <netinet/icmp6.h> ICMP6_RR_FLAGS_TEST
      <netinet/icmp6.h> ICMP6_RR_PCOUSE_FLAGS_DECRPLTIME
      <netinet/icmp6.h> ICMP6_RR_PCOUSE_FLAGS_DECRVLTIME
      <netinet/icmp6.h> ICMP6_RR_PCOUSE_RAFLAGS_AUTO
      <netinet/icmp6.h> ICMP6_RR_PCOUSE_RAFLAGS_ONLINK
      <netinet/icmp6.h> ICMP6_RR_RESULT_FLAGS_FORBIDDEN
      <netinet/icmp6.h> ICMP6_RR_RESULT_FLAGS_OOB
      <netinet/icmp6.h> ICMP6_TIME_EXCEEDED
      <netinet/icmp6.h> ICMP6_TIME_EXCEED_REASSEMBLY
      <netinet/icmp6.h> ICMP6_TIME_EXCEED_TRANSIT
      <netinet/icmp6.h> MLD_LISTENER_QUERY
      <netinet/icmp6.h> MLD_LISTENER_REDUCTION
      <netinet/icmp6.h> MLD_LISTENER_REPORT
      <netinet/icmp6.h> ND_NA_FLAG_OVERRIDE
      <netinet/icmp6.h> ND_NA_FLAG_ROUTER
      <netinet/icmp6.h> ND_NA_FLAG_SOLICITED
      <netinet/icmp6.h> ND_NEIGHBOR_ADVERT
      <netinet/icmp6.h> ND_NEIGHBOR_SOLICIT
      <netinet/icmp6.h> ND_OPT_MTU
      <netinet/icmp6.h> ND_OPT_PI_FLAG_AUTO
      <netinet/icmp6.h> ND_OPT_PI_FLAG_ONLINK
      <netinet/icmp6.h> ND_OPT_PREFIX_INFORMATION
      <netinet/icmp6.h> ND_OPT_REDIRECTED_HEADER
      <netinet/icmp6.h> ND_OPT_SOURCE_LINKADDR
      <netinet/icmp6.h> ND_OPT_TARGET_LINKADDR
      <netinet/icmp6.h> ND_RA_FLAG_MANAGED
      <netinet/icmp6.h> ND_RA_FLAG_OTHER
      <netinet/icmp6.h> ND_REDIRECT
      <netinet/icmp6.h> ND_ROUTER_ADVERT
      <netinet/icmp6.h> ND_ROUTER_SOLICIT

      <netinet/icmp6.h> struct icmp6_filter{};
      <netinet/icmp6.h> struct icmp6_hdr{};
      <netinet/icmp6.h> struct icmp6_router_renum{};
      <netinet/icmp6.h> struct mld_hdr{};
      <netinet/icmp6.h> struct nd_neighbor_advert{};
      <netinet/icmp6.h> struct nd_neighbor_solicit{};
      <netinet/icmp6.h> struct nd_opt_hdr{};



Stevens, et al.              Informational                     [Page 53]

RFC 3542             Advanced Sockets API for IPv6              May 2003


      <netinet/icmp6.h> struct nd_opt_mtu{};
      <netinet/icmp6.h> struct nd_opt_prefix_info{};
      <netinet/icmp6.h> struct nd_opt_rd_hdr{};
      <netinet/icmp6.h> struct nd_redirect{};
      <netinet/icmp6.h> struct nd_router_advert{};
      <netinet/icmp6.h> struct nd_router_solicit{};
      <netinet/icmp6.h> struct rr_pco_match{};
      <netinet/icmp6.h> struct rr_pco_use{};
      <netinet/icmp6.h> struct rr_result{};

      <netinet/in.h>    IPPROTO_AH
      <netinet/in.h>    IPPROTO_DSTOPTS
      <netinet/in.h>    IPPROTO_ESP
      <netinet/in.h>    IPPROTO_FRAGMENT
      <netinet/in.h>    IPPROTO_HOPOPTS
      <netinet/in.h>    IPPROTO_ICMPV6
      <netinet/in.h>    IPPROTO_IPV6
      <netinet/in.h>    IPPROTO_NONE
      <netinet/in.h>    IPPROTO_ROUTING
      <netinet/in.h>    IPV6_CHECKSUM
      <netinet/in.h>    IPV6_DONTFRAG
      <netinet/in.h>    IPV6_DSTOPTS
      <netinet/in.h>    IPV6_HOPLIMIT
      <netinet/in.h>    IPV6_HOPOPTS

      <netinet/in.h>    IPV6_NEXTHOP
      <netinet/in.h>    IPV6_PATHMTU
      <netinet/in.h>    IPV6_PKTINFO
      <netinet/in.h>    IPV6_RECVDSTOPTS
      <netinet/in.h>    IPV6_RECVHOPLIMIT
      <netinet/in.h>    IPV6_RECVHOPOPTS
      <netinet/in.h>    IPV6_RECVPKTINFO
      <netinet/in.h>    IPV6_RECVRTHDR
      <netinet/in.h>    IPV6_RECVTCLASS
      <netinet/in.h>    IPV6_RTHDR
      <netinet/in.h>    IPV6_RTHDRDSTOPTS
      <netinet/in.h>    IPV6_RTHDR_TYPE_0
      <netinet/in.h>    IPV6_RECVPATHMTU
      <netinet/in.h>    IPV6_TCLASS
      <netinet/in.h>    IPV6_USE_MIN_MTU
      <netinet/in.h>    struct in6_pktinfo{};
      <netinet/in.h>    struct ip6_mtuinfo{};

      <netinet/ip6.h>   IP6F_MORE_FRAG
      <netinet/ip6.h>   IP6F_OFF_MASK
      <netinet/ip6.h>   IP6F_RESERVED_MASK
      <netinet/ip6.h>   IP6OPT_JUMBO
      <netinet/ip6.h>   IP6OPT_JUMBO_LEN



Stevens, et al.              Informational                     [Page 54]

RFC 3542             Advanced Sockets API for IPv6              May 2003


      <netinet/ip6.h>   IP6OPT_MUTABLE
      <netinet/ip6.h>   IP6OPT_NSAP_ADDR
      <netinet/ip6.h>   IP6OPT_PAD1
      <netinet/ip6.h>   IP6OPT_PADN
      <netinet/ip6.h>   IP6OPT_ROUTER_ALERT
      <netinet/ip6.h>   IP6OPT_TUNNEL_LIMIT
      <netinet/ip6.h>   IP6OPT_TYPE_DISCARD
      <netinet/ip6.h>   IP6OPT_TYPE_FORCEICMP
      <netinet/ip6.h>   IP6OPT_TYPE_ICMP
      <netinet/ip6.h>   IP6OPT_TYPE_SKIP
      <netinet/ip6.h>   IP6_ALERT_AN
      <netinet/ip6.h>   IP6_ALERT_MLD
      <netinet/ip6.h>   IP6_ALERT_RSVP
      <netinet/ip6.h>   struct ip6_dest{};
      <netinet/ip6.h>   struct ip6_frag{};
      <netinet/ip6.h>   struct ip6_hbh{};
      <netinet/ip6.h>   struct ip6_hdr{};
      <netinet/ip6.h>   struct ip6_opt{};
      <netinet/ip6.h>   struct ip6_opt_jumbo{};
      <netinet/ip6.h>   struct ip6_opt_nsap{};
      <netinet/ip6.h>   struct ip6_opt_router{};
      <netinet/ip6.h>   struct ip6_opt_tunnel{};
      <netinet/ip6.h>   struct ip6_rthdr{};
      <netinet/ip6.h>   struct ip6_rthdr0{};

   The following list summarizes the function and macro prototypes
   discussed in this memo, sorted by header.

      <netinet/icmp6.h> void ICMP6_FILTER_SETBLOCK(int, struct
                                               icmp6_filter *);
      <netinet/icmp6.h> void
                        ICMP6_FILTER_SETBLOCKALL(struct icmp6_filter *);
      <netinet/icmp6.h> void
                        ICMP6_FILTER_SETPASS(int,
                                             struct icmp6_filter *);
      <netinet/icmp6.h> void
                        ICMP6_FILTER_SETPASSALL(struct icmp6_filter *);
      <netinet/icmp6.h> int  ICMP6_FILTER_WILLBLOCK(int,
                                           const struct icmp6_filter *);
      <netinet/icmp6.h> int  ICMP6_FILTER_WILLPASS(int,
                                           const struct icmp6_filter *);

      <netinet/in.h>    int IN6_ARE_ADDR_EQUAL(const struct in6_addr *,
                                           const struct in6_addr *);

      <netinet/in.h>    int inet6_opt_append(void *, socklen_t, int,
                                             uint8_t, socklen_t, uint_t,
                                             void **);



Stevens, et al.              Informational                     [Page 55]

RFC 3542             Advanced Sockets API for IPv6              May 2003


      <netinet/in.h>    int inet6_opt_get_val(void *, int, void *,
                                              socklen_t);
      <netinet/in.h>    int inet6_opt_find(void *, socklen_t,
                                           int, uint8_t ,
                                           socklen_t *, void **);
      <netinet/in.h>    int inet6_opt_finish(void *, socklen_t, int);
      <netinet/in.h>    int inet6_opt_init(void *, socklen_t);
      <netinet/in.h>    int inet6_opt_next(void *, socklen_t,
                                           int, uint8_t *,
                                           socklen_t *, void **);
      <netinet/in.h>    int inet6_opt_set_val(void *, int,
                                              void *, socklen_t);

      <netinet/in.h>    int inet6_rth_add(void *,
                                          const struct in6_addr *);
      <netinet/in.h>    struct in6_addr inet6_rth_getaddr(const void *,
                                                          int);
      <netinet/in.h>    void *inet6_rth_init(void *, socklen_t,
                                             int, int);
      <netinet/in.h>    int inet6_rth_reverse(const void *, void *);
      <netinet/in.h>    int inet6_rth_segments(const void *);
      <netinet/in.h>    soccklen_t inet6_rth_space(int, int);

      <netinet/ip6.h>   int  IP6OPT_TYPE(uint8_t);

      <sys/socket.h>    socklen_t CMSG_LEN(socklen_t);
      <sys/socket.h>    socklen_t CMSG_SPACE(socklen_t);

      <unistd.h>        int rresvport_af(int *, int);
      <unistd.h>        int rcmd_af(char **, unsigned short,
                                    const char *, const char *,
                                    const char *, int *, int);
      <unistd.h>        int rexec_af(char **, unsigned short,
                                     const char *, const char *,
                                     const char *, int *, int);

16.  Security Considerations

   The setting of certain Hop-by-Hop options and Destination options may
   be restricted to privileged processes.  Similarly some Hop-by-Hop
   options and Destination options may not be returned to non-privileged
   applications.

   The ability to specify an arbitrary source address using IPV6_PKTINFO
   must be prevented; at least for non-privileged processes.






Stevens, et al.              Informational                     [Page 56]

RFC 3542             Advanced Sockets API for IPv6              May 2003


17.  Changes from RFC 2292

   Significant changes that affect the compatibility to RFC 2292:

   -  Removed the IPV6_PKTOPTIONS socket option by allowing sticky
      options to be set with individual setsockopt() calls.

   -  Removed the ability to be able to specify Hop-by-Hop and
      Destination options using multiple ancillary data items.  The
      application, using the inet6_opt_xxx() routines (see below), is
      responsible for formatting the whole extension header.

   -  Removed the support for the loose/strict Routing header since that
      has been removed from the IPv6 specification.

   -  Loosened the constraints for jumbo payload option that this option
      was always hidden from applications.

   -  Disabled the use of the IPV6_HOPLIMIT sticky option.

   -  Removed ip6r0_addr field from the ip6_rthdr structure.

   -  Intentionally unspecified how to get received packet's information
      on TCP sockets.

   New features:

   -  Added IPV6_RTHDRDSTOPTS to specify a Destination Options header
      before the Routing header.

   -  Added separate IPV6_RECVxxx options to enable the receipt of the
      corresponding ancillary data items.

   -  Added inet6_rth_xxx() and inet6_opt_xxx() functions to deal with
      routing or IPv6 options headers.

   -  Added extensions of libraries for the "r" commands.

   -  Introduced additional IPv6 option definitions such as IP6OPT_PAD1.

   -  Added MLD and router renumbering definitions.

   -  Added MTU-related socket options and ancillary data items.

   -  Added options and ancillary data items to manipulate the traffic
      class field.





Stevens, et al.              Informational                     [Page 57]

RFC 3542             Advanced Sockets API for IPv6              May 2003


   -  Changed the name of ICMPv6 unreachable code 2 to be "beyond scope
      of source address."  ICMP6_DST_UNREACH_NOTNEIGHBOR was removed
      with this change.

   Clarifications:

   -  Added clarifications on extension headers ordering; for the
      sending side, assume the recommended ordering described in RFC
      2460.  For the receiving side, do not assume any ordering and pass
      all headers to the application in the received order.

   -  Added a summary about the interface selection rule.

   -  Clarified the ordering between IPV6_MULTICAST_IF and the
      IPV6_PKTINFO sticky option for multicast packets.

   -  Clarified how sticky options and the ICMPv6 filter are turned off
      and that getsockopt() of a sticky option returns what was set with
      setsockopt().

   -  Clarified that IPV6_NEXTHOP should be ignored for a multicast
      destination, that it should not contradict with the specified
      outgoing interface, and that the next hop should be a sockaddr_in6
      structure.

 





   
   (which is always in the form "xn," where x can have the values 1, 2,
   4, or 8) and the total size of the data portion of the option.  These
   

   functions below need to know the alignment of the end of the option
   (which is always in the form "xn," where x can have the values 1, 2,
   4, or 8) and the total size of the data portion of the option.  These
   are passed as the "align" and "len" arguments to inet6_opt_append().

   Multiple Hop-by-Hop options must be specified by the application by
   placing them in a single extension header.

   Finally, we note that use of some Hop-by-Hop options or some
   Destination options, might require special privilege.  That is,
   normal applications (without special privilege) might be forbidden
   from setting certain options in outgoing packets, and might never see
   certain options in received packets.

8.1.  Receiving Hop-by-Hop Options

   To receive a Hop-by-Hop options header the application must enable
   the IPV6_RECVHOPOPTS socket option:

      int  on = 1;
      setsockopt(fd, IPPROTO_IPV6, IPV6_RECVHOPOPTS, &on, sizeof(on));

   When using ancillary data a Hop-by-hop options header is passed
   between the application and the kernel as follows: The cmsg_level
   member will be IPPROTO_IPV6 and the cmsg_type member will be
   IPV6_HOPOPTS.  These options are then processed by calling the
   inet6_opt_next(), inet6_opt_find(), and inet6_opt_get_val()
   functions, described in Section 10.

8.2.  Sending Hop-by-Hop Options

   To send a Hop-by-Hop options header, the application specifies the
   header either as ancillary data in a call to sendmsg() or using
   setsockopt().

   The application can remove any sticky Hop-by-Hop options header by
   calling setsockopt() for IPV6_HOPOPTS with a zero option length.

   All the Hop-by-Hop options must be specified by a single ancillary
   data object.  The cmsg_level member is set to IPPROTO_IPV6 and the
   cmsg_type member is set to IPV6_HOPOPTS.  The option is normally
   constructed using the inet6_opt_init(), inet6_opt_append(),
   inet6_opt_finish(), and inet6_opt_set_val() functions, described in
   Section 10.

   Additional errors may be possible from sendmsg() and setsockopt() if
   the specified option is in error.




Stevens, et al.              Informational                     [Page 38]

RFC 3542             Advanced Sockets API for IPv6              May 2003


9.  Destination Options

   A variable number of Destination options can appear in one or more
   Destination options headers.  As defined in [RFC-2460], a Destination
   options header appearing before a Routing header is processed by the
   first destination plus any subsequent destinations specified in the
   Routing header, while a Destination options header that is not
   followed by a Routing header is processed only by the final
   destination.  As with the Hop-by-Hop options, each option in a
   Destination options header is TLV-encoded with a type, length, and
   value.

9.1.  Receiving Destination Options

   To receive Destination options header the application must enable the
   IPV6_RECVDSTOPTS socket option:

      int  on = 1;
      setsockopt(fd, IPPROTO_IPV6, IPV6_RECVDSTOPTS, &on, sizeof(on));

   Each Destination options header is returned as one ancillary data
   object described by a cmsghdr structure with cmsg_level set to
   IPPROTO_IPV6 and cmsg_type set to IPV6_DSTOPTS.

   These options are then processed by calling the inet6_opt_next(),
   inet6_opt_find(), and inet6_opt_get_value() functions.

9.2.  Sending Destination Options

   To send a Destination options header, the application specifies it
   either as ancillary data in a call to sendmsg() or using
   setsockopt().

   The application can remove any sticky Destination options header by
   calling setsockopt() for IPV6_RTHDRDSTOPTS/IPV6_DSTOPTS with a zero
   option length.

   This API assumes the ordering about extension headers as described in
   [RFC-2460].  Thus, one set of Destination options can only appear
   before a Routing header, and one set can only appear after a Routing
   header (or in a packet with no Routing header).  Each set can consist
   of one or more options but each set is a single extension header.

   Today all destination options that an application may want to specify
   can be put after (or without) a Routing header.  Thus, applications
   should usually need IPV6_DSTOPTS only and should avoid using
   IPV6_RTHDRDSTOPTS whenever possible.




Stevens, et al.              Informational                     [Page 39]

RFC 3542             Advanced Sockets API for IPv6              May 2003


   When using ancillary data a Destination options header is passed
   between the application and the kernel as follows: The set preceding
   a Routing header are specified with the cmsg_level member set to
   IPPROTO_IPV6 and the cmsg_type member set to IPV6_RTHDRDSTOPTS.  Any
   setsockopt or ancillary data for IPV6_RTHDRDSTOPTS is silently
   ignored when sending packets unless a Routing header is also
   specified.  Note that the "Routing header" here means the one
   specified by this API.  Even when the kernel inserts a routing header
   in its internal routine (e.g., in a mobile IPv6 stack), the
   Destination options header specified by IPV6_RTHDRDSTOPTS will still
   be ignored unless the application explicitly specifies its own
   Routing header.

   The set of Destination options after a Routing header, which are also
   used when no Routing header is present, are specified with the
   cmsg_level member is set to IPPROTO_IPV6 and the cmsg_type member is
   set to IPV6_DSTOPTS.

   The Destination options are normally constructed using the
   inet6_opt_init(), inet6_opt_append(), inet6_opt_finish(), and
   inet6_opt_set_val() functions, described in Section 10.

   Additional errors may be possible from sendmsg() and setsockopt() if
   the specified option is in error.

10.  Hop-by-Hop and Destination Options Processing

   Building and parsing the Hop-by-Hop and Destination options is
   complicated for the reasons given earlier.  We therefore define a set
   of functions to help the application.  These functions assume the
   formatting rules specified in Appendix B in [RFC-2460] i.e., that the
   largest field is placed last in the option.

   The function prototypes for these functions are defined as a result
   of including <netinet/in.h>.

   The first 3 functions (init, append, and finish) are used both to
   calculate the needed buffer size for the options, and to actually
   encode the options once the application has allocated a buffer for
   the header.  In order to only calculate the size the application must
   pass a NULL extbuf and a zero extlen to those functions.










Stevens, et al.              Informational                     [Page 40]

RFC 3542             Advanced Sockets API for IPv6              May 2003


10.1.  inet6_opt_init

      int inet6_opt_init(void *extbuf, socklen_t extlen);

   This function returns the number of bytes needed for the empty
   extension header i.e., without any options.  If extbuf is not NULL it
   also initializes the extension header to have the correct length
   field.  In that case if the extlen value is not a positive (i.e.,
   non-zero) multiple of 8 the function fails and returns -1.

   (Note: since the return value on success is based on a "constant"
   parameter, i.e., the empty extension header, an implementation may
   return a constant value.  However, this specification does not
   require the value be constant, and leaves it as implementation
   dependent.  The application should not assume a particular constant
   value as a successful return value of this function.)

10.2.  inet6_opt_append

      int inet6_opt_append(void *extbuf, socklen_t extlen, int offset,
                           uint8_t type, socklen_t len, uint_t align,
                           void **databufp);

   Offset should be the length returned by inet6_opt_init() or a
   previous inet6_opt_append().  This function returns the updated total
   length taking into account adding an option with length 'len' and
   alignment 'align'.  If extbuf is not NULL then, in addition to
   returning the length, the function inserts any needed pad option,
   initializes the option (setting the type and length fields) and
   returns a pointer to the location for the option content in databufp.
   If the option does not fit in the extension header buffer the
   function returns -1.

   Type is the 8-bit option type.  Len is the length of the option data
   (i.e., excluding the option type and option length fields).

   Once inet6_opt_append() has been called the application can use the
   databuf directly, or use inet6_opt_set_val() to specify the content
   of the option.

   The option type must have a value from 2 to 255, inclusive.  (0 and 1
   are reserved for the Pad1 and PadN options, respectively.)

   The option data length must have a value between 0 and 255,
   inclusive, and is the length of the option data that follows.

   The align parameter must have a value of 1, 2, 4, or 8.  The align
   value can not exceed the value of len.



Stevens, et al.              Informational                     [Page 41]

RFC 3542             Advanced Sockets API for IPv6              May 2003


10.3.  inet6_opt_finish

      int inet6_opt_finish(void *extbuf, socklen_t extlen, int offset);

   Offset should be the length returned by inet6_opt_init() or
   inet6_opt_append().  This function returns the updated total length
   taking into account the final padding of the extension header to make
   it a multiple of 8 bytes.  If extbuf is not NULL the function also
   initializes the option by inserting a Pad1 or PadN option of the
   proper length.

   If the necessary pad does not fit in the extension header buffer the
   function returns -1.

10.4.  inet6_opt_set_val

      int inet6_opt_set_val(void *databuf, int offset, void *val,
                            socklen_t vallen);

   Databuf should be a pointer returned by inet6_opt_append().  This
   function inserts data items of various sizes in the data portion of
   the option.  Val should point to the data to be inserted.  Offset
   specifies where in the data portion of the option the value should be
   inserted; the first byte after the option type and length is accessed
   by specifying an offset of zero.

   The caller should ensure that each field is aligned on its natural
   boundaries as described in Appendix B of [RFC-2460], but the function
   must not rely on the caller's behavior.  Even when the alignment
   requirement is not satisfied, inet6_opt_set_val should just copy the
   data as required.

   The function returns the offset for the next field (i.e., offset +
   vallen) which can be used when composing option content with multiple
   fields.

10.5.  inet6_opt_next

      int inet6_opt_next(void *extbuf, socklen_t extlen, int offset,
                         uint8_t *typep, socklen_t *lenp,
                         void **databufp);

   This function parses received option extension headers returning the
   next option.  Extbuf and extlen specifies the extension header.
   Offset should either be zero (for the first option) or the length
   returned by a previous call to inet6_opt_next() or inet6_opt_find().
   It specifies the position where to continue scanning the extension
   buffer.  The next option is returned by updating typep, lenp, and



Stevens, et al.              Informational                     [Page 42]

RFC 3542             Advanced Sockets API for IPv6              May 2003


   databufp.  Typep stores the option type, lenp stores the length of
   the option data (i.e., excluding the option type and option length
   fields), and databufp points the data field of the option.  This
   function returns the updated "previous" length computed by advancing
   past the option that was returned.  This returned "previous" length
   can then be passed to subsequent calls to inet6_opt_next().  This
   function does not return any PAD1 or PADN options.  When there are no
   more options or if the option extension header is malformed the
   return value is -1.

10.6.  inet6_opt_find

      int inet6_opt_find(void *extbuf, socklen_t extlen, int offset,
                         uint8_t type, socklen_t *lenp,
                         void **databufp);

   This function is similar to the previously described inet6_opt_next()
   function, except this function lets the caller specify the option
   type to be searched for, instead of always returning the next option
   in the extension header.

   If an option of the specified type is located, the function returns
   the updated "previous" total length computed by advancing past the
   option that was returned and past any options that didn't match the
   type.  This returned "previous" length can then be passed to
   subsequent calls to inet6_opt_find() for finding the next occurrence
   of the same option type.

   If an option of the specified type is not located, the return value
   is -1.  If the option extension header is malformed, the return value
   is -1.

10.7.  inet6_opt_get_val

      int inet6_opt_get_val(void *databuf, int offset, void *val,
                            socklen_t vallen);

   Databuf should be a pointer returned by inet6_opt_next() or
   inet6_opt_find().  This function extracts data items of various sizes
   in the data portion of the option.  Val should point to the
   destination for the extracted data.  Offset specifies from where in
   the data portion of the option the value should be extracted; the
   first byte after the option type and length is accessed by specifying
   an offset of zero.

   It is expected that each field is aligned on its natural boundaries
   as described in Appendix B of [RFC-2460], but the function must not
   rely on the alignment.



Stevens, et al.              Informational                     [Page 43]

RFC 3542             Advanced Sockets API for IPv6              May 2003


   The function returns the offset for the next field (i.e., offset +
   vallen) which can be used when extracting option content with
   multiple fields.

11.  Additional Advanced API Functions

11.1.  Sending with the Minimum MTU

   Unicast applications should usually let the kernel perform path MTU
   discovery [RFC-1981], as long as the kernel supports it, and should
   not care about the path MTU.  Some applications, however, might not
   want to incur the overhead of path MTU discovery, especially if the
   applications only send a single datagram to a destination.  A
   potential example is a DNS server.

   [RFC-1981] describes how path MTU discovery works for multicast
   destinations.  From practice in using IPv4 multicast, however, many
   careless applications that send large multicast packets on the wire
   have caused implosion of ICMPv4 error messages.  The situation can be
   worse when there is a filtering node that blocks the ICMPv4 messages.
   Though the filtering issue applies to unicast as well, the impact is
   much larger in the multicast cases.

   Thus, applications sending multicast traffic should explicitly enable
   path MTU discovery only when they understand that the benefit of
   possibly larger MTU usage outweighs the possible impact of MTU
   discovery for active sources across the delivery tree(s).  This
   default behavior is based on the today's practice with IPv4 multicast
   and path MTU discovery.  The behavior may change in the future once
   it is found that path MTU discovery effectively works with actual
   multicast applications and network configurations.

   This specification defines a mechanism to avoid path MTU discovery by
   sending at the minimum IPv6 MTU [RFC-2460].  If the packet is larger
   than the minimum MTU and this feature has been enabled the IP layer
   will fragment to the minimum MTU.  To control the policy about path
   MTU discovery, applications can use the IPV6_USE_MIN_MTU socket
   option.

   As described above, the default policy should depend on whether the
   destination is unicast or multicast.  For unicast destinations path
   MTU discovery should be performed by default.  For multicast
   destinations path MTU discovery should be disabled by default.  This
   option thus takes the following three types of integer arguments:

   -1: perform path MTU discovery for unicast destinations but do not
       perform it for multicast destinations.  Packets to multicast
       destinations are therefore sent with the minimum MTU.



Stevens, et al.              Informational                     [Page 44]

RFC 3542             Advanced Sockets API for IPv6              May 2003


   0: always perform path MTU discovery.

   1: always disable path MTU discovery and send packets at the minimum
       MTU.

   The default value of this option is -1.  Values other than -1, 0, and
   1 are invalid, and an error EINVAL will be returned for those values.

   As an example, if a unicast application intentionally wants to
   disable path MTU discovery, it will add the following lines:

      int  on = 1;
      setsockopt(fd, IPPROTO_IPV6, IPV6_USE_MIN_MTU, &on, sizeof(on));

   Note that this API intentionally excludes the case where the
   application wants to perform path MTU discovery for multicast but to
   disable it for unicast.  This is because such usage is not feasible
   considering a scale of performance issues around whether to do path
   MTU discovery or not.  When path MTU discovery makes sense to a
   destination but not to a different destination, regardless of whether
   the destination is unicast or multicast, applications either need to
   toggle the option between sending such packets on the same socket, or
   use different sockets for the two classes of destinations.

   This option can also be sent as ancillary data.  In the cmsghdr
   structure containing this ancillary data, the cmsg_level member will
   be IPPROTO_IPV6, the cmsg_type member will be IPV6_USE_MIN_MTU, and
   the first byte of cmsg_data[] will be the first byte of the integer.

11.2.  Sending without Fragmentation

   In order to provide for easy porting of existing UDP and raw socket
   applications IPv6 implementations will, when originating packets,
   automatically insert a fragment header in the packet if the packet is
   too big for the path MTU.

   Some applications might not want this behavior.  An example is
   traceroute which might want to discover the actual path MTU.

   This specification defines a mechanism to turn off the automatic
   inserting of a fragment header for UDP and raw sockets.  This can be
   enabled using the IPV6_DONTFRAG socket option.

      int on = 1;
      setsockopt(fd, IPPROTO_IPV6, IPV6_DONTFRAG, &on, sizeof(on));






Stevens, et al.              Informational                     [Page 45]

RFC 3542             Advanced Sockets API for IPv6              May 2003


   By default, this socket option is disabled.  Setting the value to 0
   also disables the option i.e., reverts to the default behavior of
   automatic inserting.  This option can also be sent as ancillary data.
   In the cmsghdr structure containing this ancillary data, the
   cmsg_level member will be IPPROTO_IPV6, the cmsg_type member will be
   IPV6_DONTFRAG, and the first byte of cmsg_data[] will be the first
   byte of the integer.  This API only specifies the use of this option
   for UDP and raw sockets, and does not define the usage for TCP
   sockets.

   When the data size is larger than the MTU of the outgoing interface,
   the packet will be discarded.  Applications can know the result by
   enabling the IPV6_RECVPATHMTU option described below and receiving
   the corresponding ancillary data items.  An additional error EMSGSIZE
   may also be returned in some implementations.  Note, however, that
   some other implementations might not be able to return this
   additional error when sending a message.

11.3.  Path MTU Discovery and UDP

   UDP and raw socket applications need to be able to  determine the
   "maximum send transport-message size" (Section 5.1 of [RFC-1981]) to
   a given destination so that those applications can participate in
   path MTU discovery.  This lets those applications send smaller
   datagrams to the destination, avoiding fragmentation.

   This is accomplished using a new ancillary data item (IPV6_PATHMTU)
   which is delivered to recvmsg() without any actual data.  The
   application can enable the receipt of IPV6_PATHMTU ancillary data
   items by setting the IPV6_RECVPATHMTU socket option.

      int  on = 1;
      setsockopt(fd, IPPROTO_IPV6, IPV6_RECVPATHMTU, &on, sizeof(on));

   By default, this socket option is disabled.  Setting the value to 0
   also disables the option.  This API only specifies the use of this
   option for UDP and raw sockets, and does not define the usage for TCP
   sockets.

   When the application is sending packets too big for the path MTU
   recvmsg() will return zero (indicating no data) but there will be a
   cmsghdr with cmsg_type set to IPV6_PATHMTU, and cmsg_len will
   indicate that cmsg_data is sizeof(struct ip6_mtuinfo) bytes long.
   This can happen when the sending node receives a corresponding ICMPv6
   packet too big error, or when the packet is sent from a socket with
   the IPV6_DONTFRAG option being on and the packet size is larger than
   the MTU of the outgoing interface.  This indication is considered as
   an ancillary data item for a separate (empty) message.  Thus, when



Stevens, et al.              Informational                     [Page 46]

RFC 3542             Advanced Sockets API for IPv6              May 2003


   there are buffered messages (i.e., messages that the application has
   not received yet) on the socket the application will first receive
   the buffered messages and then receive the indication.

   The first byte of cmsg_data[] will point to a struct ip6_mtuinfo
   carrying the path MTU to use together with the IPv6 destination
   address.

      struct ip6_mtuinfo {
        struct sockaddr_in6 ip6m_addr; /* dst address including
                                          zone ID */
        uint32_t            ip6m_mtu;  /* path MTU in host byte order */
      };

   This cmsghdr will be passed to every socket that sets the
   IPV6_RECVPATHMTU socket option, even if the socket is non-connected.
   Note that this also means an application that sets the option may
   receive an IPV6_MTU ancillary data item for each ICMP too big error
   the node receives, including such ICMP errors caused by other
   applications on the node.  Thus, an application that wants to perform
   the path MTU discovery by itself needs to keep history of
   destinations that it has actually sent to and to compare the address
   returned in the ip6_mtuinfo structure to the history.  An
   implementation may choose not to delivery data to a connected socket
   that has a foreign address that is different than the address
   specified in the ip6m_addr structure.

   When an application sends a packet with a routing header, the final
   destination stored in the ip6m_addr member does not necessarily
   contain complete information of the entire path.

11.4.  Determining the Current Path MTU

   Some applications might need to determine the current path MTU e.g.,
   applications using IPV6_RECVPATHMTU might want to pick a good
   starting value.

   This specification defines a get-only socket option to retrieve the
   current path MTU value for the destination of a given connected
   socket.  If the IP layer does not have a cached path MTU value it
   will return the interface MTU for the interface that will be used
   when sending to the destination address.

   This information is retrieved using the IPV6_PATHMTU socket option.
   This option takes a pointer to the ip6_mtuinfo structure as the
   fourth argument, and the size of the structure should be passed as a
   value-result parameter in the fifth argument.




Stevens, et al.              Informational                     [Page 47]

RFC 3542             Advanced Sockets API for IPv6              May 2003


      struct ip6_mtuinfo mtuinfo;
      socklen_t infolen = sizeof(mtuinfo);

      getsockopt(fd, IPPROTO_IPV6, IPV6_PATHMTU, &mtuinfo, &infolen);

   When the call succeeds, the path MTU value is stored in the ip6m_mtu
   member of the ip6_mtuinfo structure.  Since the socket is connected,
   the ip6m_addr member is meaningless and should not be referred to by
   the application.

   This option can only be used for a connected socket, because a non-
   connected socket does not have the information of the destination and
   there is no way to pass the destination via getsockopt().  When
   getsockopt() for this option is issued on a non-connected socket, the
   call will fail.  Despite this limitation, this option is still useful
   from a practical point of view, because applications that care about
   the path MTU tend to send a lot of packets to a single destination
   and to connect the socket to the destination for performance reasons.
   If the application needs to get the MTU value in a more generic way,
   it should use a more generic interface, such as routing sockets
   [TCPIPILLUST].

12.  Ordering of Ancillary Data and IPv6 Extension Headers

   Three IPv6 extension headers can be specified by the application and
   returned to the application using ancillary data with sendmsg() and
   recvmsg(): the Routing header, Hop-by-Hop options header, and
   Destination options header.  When multiple ancillary data objects are
   transferred via recvmsg() and these objects represent any of these
   three extension headers, their placement in the control buffer is
   directly tied to their location in the corresponding IPv6 datagram.
   For example, when the application has enabled the IPV6_RECVRTHDR and
   IPV6_RECVDSTOPTS options and later receives an IPv6 packet with
   extension headers in the following order:

      The IPv6 header
      A Hop-by-Hop options header
      A Destination options header (1)
      A Routing header
      An Authentication header
      A Destination options header (2)
      A UDP header and UDP data









Stevens, et al.              Informational                     [Page 48]

RFC 3542             Advanced Sockets API for IPv6              May 2003


   then the application will receive three ancillary data objects in the
   following order:

      an object with cmsg_type set to IPV6_DSTOPTS, which represents
      the destination options header (1)
      an object with cmsg_type set to IPV6_RTHDR, which represents the
      Routing header
      an object with cmsg_type set to IPV6_DSTOPTS, which represents the
      destination options header (2)

   This example follows the header ordering described in [RFC-2460], but
   the receiving side of this specification does not assume the
   ordering.  Applications may receive any numbers of objects in any
   order according to the ordering of the received IPv6 datagram.

   For the sending side, however, this API imposes some ordering
   constraints according to [RFC-2460].  Applications using this API
   cannot make a packet with extension headers that do not follow the
   ordering.  Note, however, that this does not mean applications must
   always follow the restriction.  This is just a limitation in this API
   in order to give application programmers a guideline to construct
   headers in a practical manner.  Should an application need to make an
   outgoing packet in an arbitrary order about the extension headers,
   some other technique, such as the datalink interfaces BPF or DLPI,
   must be used.

   The followings are more details about the constraints:

   -  Each IPV6_xxx ancillary data object for a particular type of
      extension header can be specified at most once in a single control
      buffer.

   -  IPV6_xxx ancillary data objects can appear in any order in a
      control buffer, because there is no ambiguity of the ordering.

   -  Each set of IPV6_xxx ancillary data objects and sticky options
      will be put in the outgoing packet along with the header ordering
      described in [RFC-2460].

   -  An ancillary data object or a sticky option of IPV6_RTHDRDSTOPTS
      will affect the outgoing packet only when a Routing header is
      specified as an ancillary data object or a sticky option.
      Otherwise, the specified value for IPV6_RTHDRDSTOPTS will be
      ignored.



1.  Introduction

   A separate specification [RFC-3493] contains changes to the sockets
   API to support IP version 6.  Those changes are for TCP and UDP-based
   applications.  This document defines some of the "advanced" features
   of the sockets API that are required for applications to take
   advantage of additional features of IPv6.



Stevens, et al.              Informational                      [Page 3]

RFC 3542             Advanced Sockets API for IPv6              May 2003


   Today, the portability of applications using IPv4 raw sockets is
   quite high, but this is mainly because most IPv4 implementations
   started from a common base (the Berkeley source code) or at least
   started with the Berkeley header files.  This allows programs such as
   Ping and Traceroute, for example, to compile with minimal effort on
   many hosts that support the sockets API.  With IPv6, however, there
   is no common source code base that implementors are starting from,
   and the possibility for divergence at this level between different
   implementations is high.  To avoid a complete lack of portability
   amongst applications that use raw IPv6 sockets, some standardization
   is necessary.

   There are also features from the basic IPv6 specification that are
   not addressed in [RFC-3493]: sending and receiving Routing headers,
   Hop-by-Hop options, and Destination options, specifying the outgoing
   interface, being told of the receiving interface, and control of path
   MTU information.

   This document updates and replaces RFC 2292.  This revision is based
   on implementation experience of RFC 2292, as well as some additional
   extensions that have been found to be useful through the IPv6
   deployment.  Note, however, that further work on this document may
   still be needed.  Once the API specification becomes mature and is
   deployed among implementations, it may be formally standardized by a
   more appropriate body, such as has been done with the Basic API
   [RFC-3493].

   This document can be divided into the following main sections.

   1. Definitions of the basic constants and structures required for
      applications to use raw IPv6 sockets.  This includes structure
      definitions for the IPv6 and ICMPv6 headers and all associated
      constants (e.g., values for the Next Header field).

   2. Some basic semantic definitions for IPv6 raw sockets.  For
      example, a raw ICMPv4 socket requires the application to calculate
      and store the ICMPv4 header checksum.  But with IPv6 this would
      require the application to choose the source IPv6 address because
      the source address is part of the pseudo header that ICMPv6 now
      uses for its checksum computation.  It should be defined that with
      a raw ICMPv6 socket the kernel always calculates and stores the
      ICMPv6 header checksum.

   3. Packet information: how applications can obtain the received
      interface, destination address, and received hop limit, along with
      specifying these values on a per-packet basis.  There are a class
      of applications that need this capability and the technique should
      be portable.



Stevens, et al.              Informational                      [Page 4]

RFC 3542             Advanced Sockets API for IPv6              May 2003


   4. Access to the optional Routing header, Hop-by-Hop options, and
      Destination options extension headers.

   5. Additional features required for improved IPv6 application
      portability.

   The packet information along with access to the extension headers
   (Routing header, Hop-by-Hop options, and Destination options) are
   specified using the "ancillary data" fields that were added to the
   4.3BSD Reno sockets API in 1990.  The reason is that these ancillary
   data fields are part of the Posix standard [POSIX] and should
   therefore be adopted by most vendors.

   This document does not address application access to either the
   authentication header or the encapsulating security payload header.

   Many examples in this document omit error checking in favor of
   brevity and clarity.

   We note that some of the functions and socket options defined in this
   document may have error returns that are not defined in this
   document.  Some of these possible error returns will be recognized
   only as implementations proceed.

   Datatypes in this document follow the Posix format: intN_t means a
   signed integer of exactly N bits (e.g., int16_t) and uintN_t means an
   unsigned integer of exactly N bits (e.g., uint32_t).

   Note that we use the (unofficial) terminology ICMPv4, IGMPv4, and
   ARPv4 to avoid any confusion with the newer ICMPv6 protocol.

2.  Common Structures and Definitions

   Many advanced applications examine fields in the IPv6 header and set
   and examine fields in the various ICMPv6 headers.  Common structure
   definitions for these protocol headers are required, along with
   common constant definitions for the structure members.

   This API assumes that the fields in the protocol headers are left in
   the network byte order, which is big-endian for the Internet
   protocols.  If not, then either these constants or the fields being
   tested must be converted at run-time, using something like htons() or
   htonl().

   Two new header files are defined: <netinet/ip6.h> and
   <netinet/icmp6.h>.





Stevens, et al.              Informational                      [Page 5]

RFC 3542             Advanced Sockets API for IPv6              May 2003


   When an include file is specified, that include file is allowed to
   include other files that do the actual declaration or definition.

2.1.  The ip6_hdr Structure

   The following structure is defined as a result of including
   <netinet/ip6.h>.  Note that this is a new header.

      struct ip6_hdr {
        union {
          struct ip6_hdrctl {
            uint32_t ip6_un1_flow; /* 4 bits version, 8 bits TC, 20 bits
                                      flow-ID */
            uint16_t ip6_un1_plen; /* payload length */
            uint8_t  ip6_un1_nxt;  /* next header */
            uint8_t  ip6_un1_hlim; /* hop limit */
          } ip6_un1;
          uint8_t ip6_un2_vfc;     /* 4 bits version, top 4 bits
                                      tclass */
        } ip6_ctlun;
        struct in6_addr ip6_src;   /* source address */
        struct in6_addr ip6_dst;   /* destination address */
      };

      #define ip6_vfc   ip6_ctlun.ip6_un2_vfc
      #define ip6_flow  ip6_ctlun.ip6_un1.ip6_un1_flow
      #define ip6_plen  ip6_ctlun.ip6_un1.ip6_un1_plen
      #define ip6_nxt   ip6_ctlun.ip6_un1.ip6_un1_nxt
      #define ip6_hlim  ip6_ctlun.ip6_un1.ip6_un1_hlim
      #define ip6_hops  ip6_ctlun.ip6_un1.ip6_un1_hlim

2.1.1.  IPv6 Next Header Values

   IPv6 defines many new values for the Next Header field.  The
   following constants are defined as a result of including
   <netinet/in.h>.

      #define IPPROTO_HOPOPTS   0   /* IPv6 Hop-by-Hop options */
      #define IPPROTO_IPV6     41   /* IPv6 header */
      #define IPPROTO_ROUTING  43   /* IPv6 Routing header */
      #define IPPROTO_FRAGMENT 44   /* IPv6 fragment header */
      #define IPPROTO_ESP      50   /* encapsulating security payload */
      #define IPPROTO_AH       51   /* authentication header */
      #define IPPROTO_ICMPV6   58   /* ICMPv6 */
      #define IPPROTO_NONE     59   /* IPv6 no next header */
      #define IPPROTO_DSTOPTS  60   /* IPv6 Destination options */





Stevens, et al.              Informational                      [Page 6]

RFC 3542             Advanced Sockets API for IPv6              May 2003


   Berkeley-derived IPv4 implementations also define IPPROTO_IP to be 0.
   This should not be a problem since IPPROTO_IP is used only with IPv4
   sockets and IPPROTO_HOPOPTS only with IPv6 sockets.

2.1.2.  IPv6 Extension Headers

   Six extension headers are defined for IPv6.  We define structures for
   all except the Authentication header and Encapsulating Security
   Payload header, both of which are beyond the scope of this document.
   The following structures are defined as a result of including
   <netinet/ip6.h>.

      /* Hop-by-Hop options header */
      struct ip6_hbh {
        uint8_t  ip6h_nxt;        /* next header */
        uint8_t  ip6h_len;        /* length in units of 8 octets */
          /* followed by options */
      };

      /* Destination options header */
      struct ip6_dest {
        uint8_t  ip6d_nxt;        /* next header */
        uint8_t  ip6d_len;        /* length in units of 8 octets */
          /* followed by options */
      };

      /* Routing header */
      struct ip6_rthdr {
        uint8_t  ip6r_nxt;        /* next header */
        uint8_t  ip6r_len;        /* length in units of 8 octets */
        uint8_t  ip6r_type;       /* routing type */
        uint8_t  ip6r_segleft;    /* segments left */
          /* followed by routing type specific data */
      };

      /* Type 0 Routing header */
      struct ip6_rthdr0 {
        uint8_t  ip6r0_nxt;       /* next header */
        uint8_t  ip6r0_len;       /* length in units of 8 octets */
        uint8_t  ip6r0_type;      /* always zero */
        uint8_t  ip6r0_segleft;   /* segments left */
        uint32_t ip6r0_reserved;  /* reserved field */
          /* followed by up to 127 struct in6_addr */
      };







Stevens, et al.              Informational                      [Page 7]

RFC 3542             Advanced Sockets API for IPv6              May 2003


      /* Fragment header */
      struct ip6_frag {
        uint8_t   ip6f_nxt;       /* next header */
        uint8_t   ip6f_reserved;  /* reserved field */
        uint16_t  ip6f_offlg;     /* offset, reserved, and flag */
        uint32_t  ip6f_ident;     /* identification */
      };

      #if     BYTE_ORDER == BIG_ENDIAN
      #define IP6F_OFF_MASK       0xfff8  /* mask out offset from
                                             ip6f_offlg */
      #define IP6F_RESERVED_MASK  0x0006  /* reserved bits in
                                             ip6f_offlg */
      #define IP6F_MORE_FRAG      0x0001  /* more-fragments flag */
      #else   /* BYTE_ORDER == LITTLE_ENDIAN */
      #define IP6F_OFF_MASK       0xf8ff  /* mask out offset from
                                             ip6f_offlg */
      #define IP6F_RESERVED_MASK  0x0600  /* reserved bits in
                                             ip6f_offlg */
      #define IP6F_MORE_FRAG      0x0100  /* more-fragments flag */
      #endif




7.3.  inet6_rth_add

      int inet6_rth_add(void *bp, const struct in6_addr *addr);

   This function adds the IPv6 address pointed to by addr to the end of
   the Routing header being constructed.

   If successful, the segleft member of the Routing Header is updated to
   account for the new address in the Routing header and the return
   value of the function is 0.  Upon an error the return value of the
   function is -1.

7.4.  inet6_rth_reverse

      int inet6_rth_reverse(const void *in, void *out);

   This function takes a Routing header extension header (pointed to by
   the first argument) and writes a new Routing header that sends
   datagrams along the reverse of that route.  The function reverses the
   order of the addresses and sets the segleft member in the new Routing
   header to the number of segments.  Both arguments are allowed to
   point to the same buffer (that is, the reversal can occur in place).

   The return value of the function is 0 on success, or -1 upon an
   error.

7.5.  inet6_rth_segments

      int inet6_rth_segments(const void *bp);

   This function returns the number of segments (addresses) contained in
   the Routing header described by bp.  On success the return value is
   zero or greater.  The return value of the function is -1 upon an
   error.

7.6.  inet6_rth_getaddr

      struct in6_addr *inet6_rth_getaddr(const void *bp, int index);

   This function returns a pointer to the IPv6 address specified by
   index (which must have a value between 0 and one less than the value
   returned by inet6_rth_segments()) in the Routing header described by
   bp.  An application should first call inet6_rth_segments() to obtain
   the number of segments in the Routing header.

   Upon an error the return value of the function is NULL.





Stevens, et al.              Informational                     [Page 36]

RFC 3542             Advanced Sockets API for IPv6              May 2003


8.  Hop-By-Hop Options

   A variable number of Hop-by-Hop options can appear in a single Hop-
   by-Hop options header.  Each option in the header is TLV-encoded with
   a type, length, and value.  This IPv6 API defines seven functions
   that the application calls to build and examine a Hop-by_Hop options
   header, and the ability to use sticky options or ancillary data to
   communicate this information between the application and the kernel.
   This uses the IPV6_HOPOPTS for a Hop-by-Hop options header.

   Today several Hop-by-Hop options are defined for IPv6.  Two pad
   options, Pad1 and PadN, are for alignment purposes and are
   automatically inserted by the inet6_opt_XXX() routines and ignored by
   the inet6_opt_XXX() routines on the receive side.  This section of
   the API is therefore defined for other (and future) Hop-by-Hop
   options that an application may need to specify and receive.

   Four functions build an options header:

      inet6_opt_init()     - initialize buffer data for options header
      inet6_opt_append()   - add one TLV option to the options header
      inet6_opt_finish()   - finish adding TLV options to the options
                             header
      inet6_opt_set_val()  - add one component of the option content to
                             the option

      Three functions deal with a returned options header:

      inet6_opt_next()     - extract the next option from the options
                             header
      inet6_opt_find()     - extract an option of a specified type from
                             the header
      inet6_opt_get_val()  - retrieve one component of the option
                             content

   Individual Hop-by-Hop options (and Destination options, which are
   described in Section 9 and are very similar to the Hop-by-Hop
   options) may have specific alignment requirements.  For example, the
   4-byte Jumbo Payload length should appear on a 4-byte boundary, and
   IPv6 addresses are normally aligned on an 8-byte boundary.  These
   requirements and the terminology used with these options are
   discussed in Section 4.2 and Appendix B of [RFC-2460].  The alignment
   of first byte of each option is specified by two values, called x and
   y, written as "xn + y".  This states that the option must appear at
   an integer multiple of x bytes from the beginning of the options
   header (x can have the values 1, 2, 4, or 8), plus y bytes (y can
   have a value between 0 and 7, inclusive).  The Pad1 and PadN options
   are inserted as needed to maintain the required alignment.  The



Stevens, et al.              Informational                     [Page 37]

RFC 3542             Advanced Sockets API for IPv6              May 2003


   functions below need to know the alignment of the end of the option
   (which is always in the form "xn," where x can have the values 1, 2,
   4, or 8) and the total size of the data portion of the option.  These
   are passed as the "align" and "len" arguments to inet6_opt_append().

   Multiple Hop-by-Hop options must be specified by the application by
   placing them in a single extension header.

   Finally, we note that use of some Hop-by-Hop options or some
   Destination options, might require special privilege.  That is,
   normal applications (without special privilege) might be forbidden
   from setting certain options in outgoing packets, and might never see
   certain options in received packets.

8.1.  Receiving Hop-by-Hop Options

   To receive a Hop-by-Hop options header the application must enable
   the IPV6_RECVHOPOPTS socket option:

      int  on = 1;
      setsockopt(fd, IPPROTO_IPV6, IPV6_RECVHOPOPTS, &on, sizeof(on));

   When using ancillary data a Hop-by-hop options header is passed
   between the application and the kernel as follows: The cmsg_level
   member will be IPPROTO_IPV6 and the cmsg_type member will be
   IPV6_HOPOPTS.  These options are then processed by calling the
   inet6_opt_next(), inet6_opt_find(), and inet6_opt_get_val()
   functions, described in Section 10.

8.2.  Sending Hop-by-Hop Options

   To send a Hop-by-Hop options header, the application specifies the
   header either as ancillary data in a call to sendmsg() or using
   setsockopt().

   The application can remove any sticky Hop-by-Hop options header by
   calling setsockopt() for IPV6_HOPOPTS with a zero option length.

   All the Hop-by-Hop options must be specified by a single ancillary
   data object.  The cmsg_level member is set to IPPROTO_IPV6 and the
   cmsg_type member is set to IPV6_HOPOPTS.  The option is normally
   constructed using the inet6_opt_init(), inet6_opt_append(),
   inet6_opt_finish(), and inet6_opt_set_val() functions, described in
   Section 10.

   Additional errors may be possible from sendmsg() and setsockopt() if
   the specified option is in error.




Stevens, et al.              Informational                     [Page 38]

RFC 3542             Advanced Sockets API for IPv6              May 2003


9.  Destination Options

   A variable number of Destination options can appear in one or more
   Destination options headers.  As defined in [RFC-2460], a Destination
   options header appearing before a Routing header is processed by the
   first destination plus any subsequent destinations specified in the
   Routing header, while a Destination options header that is not
   followed by a Routing header is processed only by the final
   destination.  As with the Hop-by-Hop options, each option in a
   Destination options header is TLV-encoded with a type, length, and
   value.

9.1.  Receiving Destination Options

   To receive Destination options header the application must enable the
   IPV6_RECVDSTOPTS socket option:

      int  on = 1;
      setsockopt(fd, IPPROTO_IPV6, IPV6_RECVDSTOPTS, &on, sizeof(on));

   Each Destination options header is returned as one ancillary data
   object described by a cmsghdr structure with cmsg_level set to
   IPPROTO_IPV6 and cmsg_type set to IPV6_DSTOPTS.

   These options are then processed by calling the inet6_opt_next(),
   inet6_opt_find(), and inet6_opt_get_value() functions.

9.2.  Sending Destination Options

   To send a Destination options header, the application specifies it
   either as ancillary data in a call to sendmsg() or using
   setsockopt().

   The application can remove any sticky Destination options header by
   calling setsockopt() for IPV6_RTHDRDSTOPTS/IPV6_DSTOPTS with a zero
   option length.

   This API assumes the ordering about extension headers as described in
   [RFC-2460].  Thus, one set of Destination options can only appear
   before a Routing header, and one set can only appear after a Routing
   header (or in a packet with no Routing header).  Each set can consist
   of one or more options but each set is a single extension header.

   Today all destination options that an application may want to specify
   can be put after (or without) a Routing header.  Thus, applications
   should usually need IPV6_DSTOPTS only and should avoid using
   IPV6_RTHDRDSTOPTS whenever possible.




Stevens, et al.              Informational                     [Page 39]

RFC 3542             Advanced Sockets API for IPv6              May 2003


   When using ancillary data a Destination options header is passed
   between the application and the kernel as follows: The set preceding
   a Routing header are specified with the cmsg_level member set to
   IPPROTO_IPV6 and the cmsg_type member set to IPV6_RTHDRDSTOPTS.  Any
   setsockopt or ancillary data for IPV6_RTHDRDSTOPTS is silently
   ignored when sending packets unless a Routing header is also
   specified.  Note that the "Routing header" here means the one
   specified by this API.  Even when the kernel inserts a routing header
   in its internal routine (e.g., in a mobile IPv6 stack), the
   Destination options header specified by IPV6_RTHDRDSTOPTS will still
   be ignored unless the application explicitly specifies its own
   Routing header.

   The set of Destination options after a Routing header, which are also
   used when no Routing header is present, are specified with the
   cmsg_level member is set to IPPROTO_IPV6 and the cmsg_type member is
   set to IPV6_DSTOPTS.

   The Destination options are normally constructed using the
   inet6_opt_init(), inet6_opt_append(), inet6_opt_finish(), and
   inet6_opt_set_val() functions, described in Section 10.

   Additional errors may be possible from sendmsg() and setsockopt() if
   the specified option is in error.

10.  Hop-by-Hop and Destination Options Processing

   Building and parsing the Hop-by-Hop and Destination options is
   complicated for the reasons given earlier.  We therefore define a set
   of functions to help the application.  These functions assume the
   formatting rules specified in Appendix B in [RFC-2460] i.e., that the
   largest field is placed last in the option.

   The function prototypes for these functions are defined as a result
   of including <netinet/in.h>.

   The first 3 functions (init, append, and finish) are used both to
   calculate the needed buffer size for the options, and to actually
   encode the options once the application has allocated a buffer for
   the header.  In order to only calculate the size the application must
   pass a NULL extbuf and a zero extlen to those functions.










Stevens, et al.              Informational                     [Page 40]

RFC 3542             Advanced Sockets API for IPv6              May 2003


10.1.  inet6_opt_init

      int inet6_opt_init(void *extbuf, socklen_t extlen);

   This function returns the number of bytes needed for the empty
   extension header i.e., without any options.  If extbuf is not NULL it
   also initializes the extension header to have the correct length
   field.  In that case if the extlen value is not a positive (i.e.,
   non-zero) multiple of 8 the function fails and returns -1.

   (Note: since the return value on success is based on a "constant"
   parameter, i.e., the empty extension header, an implementation may
   return a constant value.  However, this specification does not
   require the value be constant, and leaves it as implementation
   dependent.  The application should not assume a particular constant
   value as a successful return value of this function.)

10.2.  inet6_opt_append

      int inet6_opt_append(void *extbuf, socklen_t extlen, int offset,
                           uint8_t type, socklen_t len, uint_t align,
                           void **databufp);

   Offset should be the length returned by inet6_opt_init() or a
   previous inet6_opt_append().  This function returns the updated total
   length taking into account adding an option with length 'len' and
   alignment 'align'.  If extbuf is not NULL then, in addition to
   returning the length, the function inserts any needed pad option,
   initializes the option (setting the type and length fields) and
   returns a pointer to the location for the option content in databufp.
   If the option does not fit in the extension header buffer the
   function returns -1.

   Type is the 8-bit option type.  Len is the length of the option data
   (i.e., excluding the option type and option length fields).

   Once inet6_opt_append() has been called the application can use the
   databuf directly, or use inet6_opt_set_val() to specify the content
   of the option.

   The option type must have a value from 2 to 255, inclusive.  (0 and 1
   are reserved for the Pad1 and PadN options, respectively.)

   The option data length must have a value between 0 and 255,
   inclusive, and is the length of the option data that follows.

   The align parameter must have a value of 1, 2, 4, or 8.  The align
   value can not exceed the value of len.



Stevens, et al.              Informational                     [Page 41]

RFC 3542             Advanced Sockets API for IPv6              May 2003


10.3.  inet6_opt_finish

      int inet6_opt_finish(void *extbuf, socklen_t extlen, int offset);

   Offset should be the length returned by inet6_opt_init() or
   inet6_opt_append().  This function returns the updated total length
   taking into account the final padding of the extension header to make
   it a multiple of 8 bytes.  If extbuf is not NULL the function also
   initializes the option by inserting a Pad1 or PadN option of the
   proper length.

   If the necessary pad does not fit in the extension header buffer the
   function returns -1.

10.4.  inet6_opt_set_val

      int inet6_opt_set_val(void *databuf, int offset, void *val,
                            socklen_t vallen);

   Databuf should be a pointer returned by inet6_opt_append().  This
   function inserts data items of various sizes in the data portion of
   the option.  Val should point to the data to be inserted.  Offset
   specifies where in the data portion of the option the value should be
   inserted; the first byte after the option type and length is accessed
   by specifying an offset of zero.

   The caller should ensure that each field is aligned on its natural
   boundaries as described in Appendix B of [RFC-2460], but the function
   must not rely on the caller's behavior.  Even when the alignment
   requirement is not satisfied, inet6_opt_set_val should just copy the
   data as required.

   The function returns the offset for the next field (i.e., offset +
   vallen) which can be used when composing option content with multiple
   fields.

10.5.  inet6_opt_next

      int inet6_opt_next(void *extbuf, socklen_t extlen, int offset,
                         uint8_t *typep, socklen_t *lenp,
                         void **databufp);

   This function parses received option extension headers returning the
   next option.  Extbuf and extlen specifies the extension header.
   Offset should either be zero (for the first option) or the length
   returned by a previous call to inet6_opt_next() or inet6_opt_find().
   It specifies the position where to continue scanning the extension
   buffer.  The next option is returned by updating typep, lenp, and



Stevens, et al.              Informational                     [Page 42]

RFC 3542             Advanced Sockets API for IPv6              May 2003


   databufp.  Typep stores the option type, lenp stores the length of
   the option data (i.e., excluding the option type and option length
   fields), and databufp points the data field of the option.  This
   function returns the updated "previous" length computed by advancing
   past the option that was returned.  This returned "previous" length
   can then be passed to subsequent calls to inet6_opt_next().  This
   function does not return any PAD1 or PADN options.  When there are no
   more options or if the option extension header is malformed the
   return value is -1.

10.6.  inet6_opt_find

      int inet6_opt_find(void *extbuf, socklen_t extlen, int offset,
                         uint8_t type, socklen_t *lenp,
                         void **databufp);

   This function is similar to the previously described inet6_opt_next()
   function, except this function lets the caller specify the option
   type to be searched for, instead of always returning the next option
   in the extension header.

   If an option of the specified type is located, the function returns
   the updated "previous" total length computed by advancing past the
   option that was returned and past any options that didn't match the
   type.  This returned "previous" length can then be passed to
   subsequent calls to inet6_opt_find() for finding the next occurrence
   of the same option type.

   If an option of the specified type is not located, the return value
   is -1.  If the option extension header is malformed, the return value
   is -1.

10.7.  inet6_opt_get_val

      int inet6_opt_get_val(void *databuf, int offset, void *val,
                            socklen_t vallen);

   Databuf should be a pointer returned by inet6_opt_next() or
   inet6_opt_find().  This function extracts data items of various sizes
   in the data portion of the option.  Val should point to the
   destination for the extracted data.  Offset specifies from where in
   the data portion of the option the value should be extracted; the
   first byte after the option type and length is accessed by specifying
   an offset of zero.

   It is expected that each field is aligned on its natural boundaries
   as described in Appendix B of [RFC-2460], but the function must not
   rely on the alignment.



Stevens, et al.              Informational                     [Page 43]

RFC 3542             Advanced Sockets API for IPv6              May 2003


   The function returns the offset for the next field (i.e., offset +
   vallen) which can be used when extracting option content with
   multiple fields.

11.  Additional Advanced API Functions

11.1.  Sending with the Minimum MTU

   Unicast applications should usually let the kernel perform path MTU
   discovery [RFC-1981], as long as the kernel supports it, and should
   not care about the path MTU.  Some applications, however, might not
   want to incur the overhead of path MTU discovery, especially if the
   applications only send a single datagram to a destination.  A
   potential example is a DNS server.

   [RFC-1981] describes how path MTU discovery works for multicast
   destinations.  From practice in using IPv4 multicast, however, many
   careless applications that send large multicast packets on the wire
   have caused implosion of ICMPv4 error messages.  The situation can be
   worse when there is a filtering node that blocks the ICMPv4 messages.
   Though the filtering issue applies to unicast as well, the impact is
   much larger in the multicast cases.

   Thus, applications sending multicast traffic should explicitly enable
   path MTU discovery only when they understand that the benefit of
   possibly larger MTU usage outweighs the possible impact of MTU
   discovery for active sources across the delivery tree(s).  This
   default behavior is based on the today's practice with IPv4 multicast
   and path MTU discovery.  The behavior may change in the future once
   it is found that path MTU discovery effectively works with actual
   multicast applications and network configurations.

   This specification defines a mechanism to avoid path MTU discovery by
   sending at the minimum IPv6 MTU [RFC-2460].  If the packet is larger
   than the minimum MTU and this feature has been enabled the IP layer
   will fragment to the minimum MTU.  To control the policy about path
   MTU discovery, applications can use the IPV6_USE_MIN_MTU socket
   option.

   As described above, the default policy should depend on whether the
   destination is unicast or multicast.  For unicast destinations path
   MTU discovery should be performed by default.  For multicast
   destinations path MTU discovery should be disabled by default.  This
   option thus takes the following three types of integer arguments:

   -1: perform path MTU discovery for unicast destinations but do not
       perform it for multicast destinations.  Packets to multicast
       destinations are therefore sent with the minimum MTU.



Stevens, et al.              Informational                     [Page 44]

RFC 3542             Advanced Sockets API for IPv6              May 2003


   0: always perform path MTU discovery.

   1: always disable path MTU discovery and send packets at the minimum
       MTU.

   The default value of this option is -1.  Values other than -1, 0, and
   1 are invalid, and an error EINVAL will be returned for those values.

   As an example, if a unicast application intentionally wants to
   disable path MTU discovery, it will add the following lines:

      int  on = 1;
      setsockopt(fd, IPPROTO_IPV6, IPV6_USE_MIN_MTU, &on, sizeof(on));

   Note that this API intentionally excludes the case where the
   application wants to perform path MTU discovery for multicast but to
   disable it for unicast.  This is because such usage is not feasible
   considering a scale of performance issues around whether to do path
   MTU discovery or not.  When path MTU discovery makes sense to a
   destination but not to a different destination, regardless of whether
   the destination is unicast or multicast, applications either need to
   toggle the option between sending such packets on the same socket, or
   use different sockets for the two classes of destinations.

   This option can also be sent as ancillary data.  In the cmsghdr
   structure containing this ancillary data, the cmsg_level member will
   be IPPROTO_IPV6, the cmsg_type member will be IPV6_USE_MIN_MTU, and
   the first byte of cmsg_data[] will be the first byte of the integer.

11.2.  Sending without Fragmentation

   In order to provide for easy porting of existing UDP and raw socket
   applications IPv6 implementations will, when originating packets,
   automatically insert a fragment header in the packet if the packet is
   too big for the path MTU.

   Some applications might not want this behavior.  An example is
   traceroute which might want to discover the actual path MTU.

   This specification defines a mechanism to turn off the automatic
   inserting of a fragment header for UDP and raw sockets.  This can be
   enabled using the IPV6_DONTFRAG socket option.

      int on = 1;
      setsockopt(fd, IPPROTO_IPV6, IPV6_DONTFRAG, &on, sizeof(on));






Stevens, et al.              Informational                     [Page 45]

RFC 3542             Advanced Sockets API for IPv6              May 2003


   By default, this socket option is disabled.  Setting the value to 0
   also disables the option i.e., reverts to the default behavior of
   automatic inserting.  This option can also be sent as ancillary data.
   In the cmsghdr structure containing this ancillary data, the
   cmsg_level member will be IPPROTO_IPV6, the cmsg_type member will be
   IPV6_DONTFRAG, and the first byte of cmsg_data[] will be the first
   byte of the integer.  This API only specifies the use of this option
   for UDP and raw sockets, and does not define the usage for TCP
   sockets.

   When the data size is larger than the MTU of the outgoing interface,
   the packet will be discarded.  Applications can know the result by
   enabling the IPV6_RECVPATHMTU option described below and receiving
   the corresponding ancillary data items.  An additional error EMSGSIZE
   may also be returned in some implementations.  Note, however, that
   some other implementations might not be able to return this
   additional error when sending a message.

11.3.  Path MTU Discovery and UDP

   UDP and raw socket applications need to be able to  determine the
   "maximum send transport-message size" (Section 5.1 of [RFC-1981]) to
   a given destination so that those applications can participate in
   path MTU discovery.  This lets those applications send smaller
   datagrams to the destination, avoiding fragmentation.

   This is accomplished using a new ancillary data item (IPV6_PATHMTU)
   which is delivered to recvmsg() without any actual data.  The
   application can enable the receipt of IPV6_PATHMTU ancillary data
   items by setting the IPV6_RECVPATHMTU socket option.

      int  on = 1;
      setsockopt(fd, IPPROTO_IPV6, IPV6_RECVPATHMTU, &on, sizeof(on));

   By default, this socket option is disabled.  Setting the value to 0
   also disables the option.  This API only specifies the use of this
   option for UDP and raw sockets, and does not define the usage for TCP
   sockets.

   When the application is sending packets too big for the path MTU
   recvmsg() will return zero (indicating no data) but there will be a
   cmsghdr with cmsg_type set to IPV6_PATHMTU, and cmsg_len will
   indicate that cmsg_data is sizeof(struct ip6_mtuinfo) bytes long.
   This can happen when the sending node receives a corresponding ICMPv6
   packet too big error, or when the packet is sent from a socket with
   the IPV6_DONTFRAG option being on and the packet size is larger than
   the MTU of the outgoing interface.  This indication is considered as
   an ancillary data item for a separate (empty) message.  Thus, when



Stevens, et al.              Informational                     [Page 46]

RFC 3542             Advanced Sockets API for IPv6              May 2003


   there are buffered messages (i.e., messages that the application has
   not received yet) on the socket the application will first receive
   the buffered messages and then receive the indication.

   The first byte of cmsg_data[] will point to a struct ip6_mtuinfo
   carrying the path MTU to use together with the IPv6 destination
   address.

      struct ip6_mtuinfo {
        struct sockaddr_in6 ip6m_addr; /* dst address including
                                          zone ID */
        uint32_t            ip6m_mtu;  /* path MTU in host byte order */
      };

   This cmsghdr will be passed to every socket that sets the
   IPV6_RECVPATHMTU socket option, even if the socket is non-connected.
   Note that this also means an application that sets the option may
   receive an IPV6_MTU ancillary data item for each ICMP too big error
   the node receives, including such ICMP errors caused by other
   applications on the node.  Thus, an application that wants to perform
   the path MTU discovery by itself needs to keep history of
   destinations that it has actually sent to and to compare the address
   returned in the ip6_mtuinfo structure to the history.  An
   implementation may choose not to delivery data to a connected socket
   that has a foreign address that is different than the address
   specified in the ip6m_addr structure.

   When an application sends a packet with a routing header, the final
   destination stored in the ip6m_addr member does not necessarily
   contain complete information of the entire path.

11.4.  Determining the Current Path MTU

   Some applications might need to determine the current path MTU e.g.,
   applications using IPV6_RECVPATHMTU might want to pick a good
   starting value.

   This specification defines a get-only socket option to retrieve the
   current path MTU value for the destination of a given connected
   socket.  If the IP layer does not have a cached path MTU value it
   will return the interface MTU for the interface that will be used
   when sending to the destination address.

   This information is retrieved using the IPV6_PATHMTU socket option.
   This option takes a pointer to the ip6_mtuinfo structure as the
   fourth argument, and the size of the structure should be passed as a
   value-result parameter in the fifth argument.




Stevens, et al.              Informational                     [Page 47]

RFC 3542             Advanced Sockets API for IPv6              May 2003


      struct ip6_mtuinfo mtuinfo;
      socklen_t infolen = sizeof(mtuinfo);

      getsockopt(fd, IPPROTO_IPV6, IPV6_PATHMTU, &mtuinfo, &infolen);

   When the call succeeds, the path MTU value is stored in the ip6m_mtu
   member of the ip6_mtuinfo structure.  Since the socket is connected,
   the ip6m_addr member is meaningless and should not be referred to by
   the application.

   This option can only be used for a connected socket, because a non-
   connected socket does not have the information of the destination and
   there is no way to pass the destination via getsockopt().  When
   getsockopt() for this option is issued on a non-connected socket, the
   call will fail.  Despite this limitation, this option is still useful
   from a practical point of view, because applications that care about
   the path MTU tend to send a lot of packets to a single destination
   and to connect the socket to the destination for performance reasons.
   If the application needs to get the MTU value in a more generic way,
   it should use a more generic interface, such as routing sockets
   [TCPIPILLUST].

12.  Ordering of Ancillary Data and IPv6 Extension Headers

   Three IPv6 extension headers can be specified by the application and
   returned to the application using ancillary data with sendmsg() and
   recvmsg(): the Routing header, Hop-by-Hop options header, and
   Destination options header.  When multiple ancillary data objects are
   transferred via recvmsg() and these objects represent any of these
   three extension headers, their placement in the control buffer is
   directly tied to their location in the corresponding IPv6 datagram.
   For example, when the application has enabled the IPV6_RECVRTHDR and
   IPV6_RECVDSTOPTS options and later receives an IPv6 packet with
   extension headers in the following order:

      The IPv6 header
      A Hop-by-Hop options header
      A Destination options header (1)
      A Routing header
      An Authentication header
      A Destination options header (2)
      A UDP header and UDP data









Stevens, et al.              Informational                     [Page 48]

RFC 3542             Advanced Sockets API for IPv6              May 2003


   then the application will receive three ancillary data objects in the
   following order:

      an object with cmsg_type set to IPV6_DSTOPTS, which represents
      the destination options header (1)
      an object with cmsg_type set to IPV6_RTHDR, which represents the
      Routing header
      an object with cmsg_type set to IPV6_DSTOPTS, which represents the
      destination options header (2)

   This example follows the header ordering described in [RFC-2460], but
   the receiving side of this specification does not assume the
   ordering.  Applications may receive any numbers of objects in any
   order according to the ordering of the received IPv6 datagram.

   For the sending side, however, this API imposes some ordering
   constraints according to [RFC-2460].  Applications using this API
   cannot make a packet with extension headers that do not follow the
   ordering.  Note, however, that this does not mean applications must
   always follow the restriction.  This is just a limitation in this API
   in order to give application programmers a guideline to construct
   headers in a practical manner.  Should an application need to make an
   outgoing packet in an arbitrary order about the extension headers,
   some other technique, such as the datalink interfaces BPF or DLPI,
   must be used.

   The followings are more details about the constraints:

   -  Each IPV6_xxx ancillary data object for a particular type of
      extension header can be specified at most once in a single control
      buffer.

   -  IPV6_xxx ancillary data objects can appear in any order in a
      control buffer, because there is no ambiguity of the ordering.

   -  Each set of IPV6_xxx ancillary data objects and sticky options
      will be put in the outgoing packet along with the header ordering
      described in [RFC-2460].

   -  An ancillary data object or a sticky option of IPV6_RTHDRDSTOPTS
      will affect the outgoing packet only when a Routing header is
      specified as an ancillary data object or a sticky option.
      Otherwise, the specified value for IPV6_RTHDRDSTOPTS will be
      ignored.







Stevens, et al.              Informational                     [Page 49]

RFC 3542             Advanced Sockets API for IPv6              May 2003


   For example, when an application sends a UDP datagram with a control
   data buffer containing ancillary data objects in the following order:

      an object with cmsg_type set to IPV6_DSTOPTS
      an object with cmsg_type set to IPV6_RTHDRDSTOPTS
      an object with cmsg_type set to IPV6_HOPOPTS

   and the sending socket does not have any sticky options, then the
   outgoing packet would be constructed as follows:

      The IPv6 header
      A Hop-by-Hop options header
      A Destination options header
      A UDP header and UDP data

   where the destination options header corresponds to the ancillary
   data object with the type IPV6_DSTOPTS.

   Note that the constraints above do not necessarily mean that the
   outgoing packet sent on the wire always follows the header ordering
   specified in this API document.  The kernel may insert additional
   headers that break the ordering as a result.  For example, if the
   kernel supports Mobile IPv6, an additional destination options header
   may be inserted before an authentication header, even without a
   routing header.

   This API does not provide access to any other extension headers than
   the supported three types of headers.  In particular, no information
   is provided about the IP security headers on an incoming packet, nor
   can be specified for an outgoing packet.  This API is for
   applications that do not care about the existence of IP security
   headers.

13.  IPv6-Specific Options with IPv4-Mapped IPv6 Addresses

   The various socket options and ancillary data specifications defined
   in this document apply only to true IPv6 sockets.  It is possible to
   create an IPv6 socket that actually sends and receives IPv4 packets,
   using IPv4-mapped IPv6 addresses, but the mapping of the options
   defined in this document to an IPv4 datagram is beyond the scope of
   this document.

   In general, attempting to specify an IPv6-only option, such as the
   Hop-by-Hop options, Destination options, or Routing header on an IPv6
   socket that is using IPv4-mapped IPv6 addresses, will probably result
   in an error.  Some implementations, however, may provide access to





Stevens, et al.              Informational                     [Page 50]

RFC 3542             Advanced Sockets API for IPv6              May 2003


   the packet information (source/destination address, send/receive
   interface, and hop limit) on an IPv6 socket that is using IPv4-mapped
   IPv6 addresses.

14.  Extended interfaces for rresvport, rcmd and rexec

   Library functions that support the "r" commands hide the creation of
   a socket and the name resolution procedure from an application.  When
   the libraries return an AF_INET6 socket to an application that do not
   support the address family, the application may encounter an
   unexpected result when, e.g., calling getpeername() for the socket.
   In order to support AF_INET6 sockets for the "r" commands while
   keeping backward compatibility, this section defines some extensions
   to the libraries.

14.1.  rresvport_af

   The rresvport() function is used by the rcmd() function, and this
   function is in turn called by many of the "r" commands such as
   rlogin.  While new applications are not being written to use the
   rcmd() function, legacy applications such as rlogin will continue to
   use it and these will be ported to IPv6.

   rresvport() creates an IPv4/TCP socket and binds a "reserved port" to
   the socket.  Instead of defining an IPv6 version of this function we
   define a new function that takes an address family as its argument.

      #include <unistd.h>

      int  rresvport_af(int *port, int family);

   This function behaves the same as the existing rresvport() function,
   but instead of creating an AF_INET TCP socket, it can also create an
   AF_INET6 TCP socket.  The family argument is either AF_INET or
   AF_INET6, and a new error return is EAFNOSUPPORT if the address
   family is not supported.

   (Note: There is little consensus on which header defines the
   rresvport() and rcmd() function prototypes.  4.4BSD defines it in
   <unistd.h>, others in <netdb.h>, and others don't define the function
   prototypes at all.)

14.2.  rcmd_af

   The existing rcmd() function can not transparently use AF_INET6
   sockets since an application would not be prepared to handle AF_INET6
   addresses returned by e.g., getpeername() on the file descriptor
   created by rcmd().  Thus a new function is needed.



Stevens, et al.              Informational                     [Page 51]

RFC 3542             Advanced Sockets API for IPv6              May 2003


      int rcmd_af(char **ahost, unsigned short rport,
                  const char *locuser, const char *remuser,
                  const char *cmd, int *fd2p, int af)

   This function behaves the same as the existing rcmd() function, but
   instead of creating an AF_INET TCP socket, it can also create an
   AF_INET6 TCP socket.  The family argument is AF_INET, AF_INET6, or
   AF_UNSPEC.  When either AF_INET or AF_INET6 is specified, this
   function will create a socket of the specified address family.  When
   AF_UNSPEC is specified, it will try all possible address families
   until a connection can be established, and will return the associated
   socket of the connection.  A new error EAFNOSUPPORT will be returned
   if the address family is not supported.

14.3.  rexec_af

   The existing rexec() function can not transparently use AF_INET6
   sockets since an application would not be prepared to handle AF_INET6
   addresses returned by e.g., getpeername() on the file descriptor
   created by rexec().  Thus a new function is needed.

      int rexec_af(char **ahost, unsigned short rport, const char *name,
                   const char *pass, const char *cmd, int *fd2p, int af)

   This function behaves the same as the existing rexec() function, but
   instead of creating an AF_INET TCP socket, it can also create an
   AF_INET6 TCP socket.  The family argument is AF_INET, AF_INET6, or
   AF_UNSPEC.  When either AF_INET or AF_INET6 is specified, this
   function will create a socket of the specified address family.  When
   AF_UNSPEC is specified, it will try all possible address families
   until a connection can be established, and will return the associated
   socket of the connection.  A new error EAFNOSUPPORT will be returned
   if the address family is not supported.

15.  Summary of New Definitions

   The following list summarizes the constants and structure,
   definitions discussed in this memo, sorted by header.

      <netinet/icmp6.h> ICMP6_DST_UNREACH
      <netinet/icmp6.h> ICMP6_DST_UNREACH_ADDR
      <netinet/icmp6.h> ICMP6_DST_UNREACH_ADMIN
      <netinet/icmp6.h> ICMP6_DST_UNREACH_BEYONDSCOPE
      <netinet/icmp6.h> ICMP6_DST_UNREACH_NOPORT
      <netinet/icmp6.h> ICMP6_DST_UNREACH_NOROUTE
      <netinet/icmp6.h> ICMP6_ECHO_REPLY
      <netinet/icmp6.h> ICMP6_ECHO_REQUEST
      <netinet/icmp6.h> ICMP6_INFOMSG_MASK



Stevens, et al.              Informational                     [Page 52]

RFC 3542             Advanced Sockets API for IPv6              May 2003


      <netinet/icmp6.h> ICMP6_PACKET_TOO_BIG
      <netinet/icmp6.h> ICMP6_PARAMPROB_HEADER
      <netinet/icmp6.h> ICMP6_PARAMPROB_NEXTHEADER
      <netinet/icmp6.h> ICMP6_PARAMPROB_OPTION
      <netinet/icmp6.h> ICMP6_PARAM_PROB
      <netinet/icmp6.h> ICMP6_ROUTER_RENUMBERING
      <netinet/icmp6.h> ICMP6_RR_FLAGS_FORCEAPPLY
      <netinet/icmp6.h> ICMP6_RR_FLAGS_PREVDONE
      <netinet/icmp6.h> ICMP6_RR_FLAGS_REQRESULT
      <netinet/icmp6.h> ICMP6_RR_FLAGS_SPECSITE
      <netinet/icmp6.h> ICMP6_RR_FLAGS_TEST
      <netinet/icmp6.h> ICMP6_RR_PCOUSE_FLAGS_DECRPLTIME
      <netinet/icmp6.h> ICMP6_RR_PCOUSE_FLAGS_DECRVLTIME
      <netinet/icmp6.h> ICMP6_RR_PCOUSE_RAFLAGS_AUTO
      <netinet/icmp6.h> ICMP6_RR_PCOUSE_RAFLAGS_ONLINK
      <netinet/icmp6.h> ICMP6_RR_RESULT_FLAGS_FORBIDDEN
      <netinet/icmp6.h> ICMP6_RR_RESULT_FLAGS_OOB
      <netinet/icmp6.h> ICMP6_TIME_EXCEEDED
      <netinet/icmp6.h> ICMP6_TIME_EXCEED_REASSEMBLY
      <netinet/icmp6.h> ICMP6_TIME_EXCEED_TRANSIT
      <netinet/icmp6.h> MLD_LISTENER_QUERY
      <netinet/icmp6.h> MLD_LISTENER_REDUCTION
      <netinet/icmp6.h> MLD_LISTENER_REPORT
      <netinet/icmp6.h> ND_NA_FLAG_OVERRIDE
      <netinet/icmp6.h> ND_NA_FLAG_ROUTER
      <netinet/icmp6.h> ND_NA_FLAG_SOLICITED
      <netinet/icmp6.h> ND_NEIGHBOR_ADVERT
      <netinet/icmp6.h> ND_NEIGHBOR_SOLICIT
      <netinet/icmp6.h> ND_OPT_MTU
      <netinet/icmp6.h> ND_OPT_PI_FLAG_AUTO
      <netinet/icmp6.h> ND_OPT_PI_FLAG_ONLINK
      <netinet/icmp6.h> ND_OPT_PREFIX_INFORMATION
      <netinet/icmp6.h> ND_OPT_REDIRECTED_HEADER
      <netinet/icmp6.h> ND_OPT_SOURCE_LINKADDR
      <netinet/icmp6.h> ND_OPT_TARGET_LINKADDR
      <netinet/icmp6.h> ND_RA_FLAG_MANAGED
      <netinet/icmp6.h> ND_RA_FLAG_OTHER
      <netinet/icmp6.h> ND_REDIRECT
      <netinet/icmp6.h> ND_ROUTER_ADVERT
      <netinet/icmp6.h> ND_ROUTER_SOLICIT

      <netinet/icmp6.h> struct icmp6_filter{};
      <netinet/icmp6.h> struct icmp6_hdr{};
      <netinet/icmp6.h> struct icmp6_router_renum{};
      <netinet/icmp6.h> struct mld_hdr{};
      <netinet/icmp6.h> struct nd_neighbor_advert{};
      <netinet/icmp6.h> struct nd_neighbor_solicit{};
      <netinet/icmp6.h> struct nd_opt_hdr{};



Stevens, et al.              Informational                     [Page 53]

RFC 3542             Advanced Sockets API for IPv6              May 2003


      <netinet/icmp6.h> struct nd_opt_mtu{};
      <netinet/icmp6.h> struct nd_opt_prefix_info{};
      <netinet/icmp6.h> struct nd_opt_rd_hdr{};
      <netinet/icmp6.h> struct nd_redirect{};
      <netinet/icmp6.h> struct nd_router_advert{};
      <netinet/icmp6.h> struct nd_router_solicit{};
      <netinet/icmp6.h> struct rr_pco_match{};
      <netinet/icmp6.h> struct rr_pco_use{};
      <netinet/icmp6.h> struct rr_result{};

      <netinet/in.h>    IPPROTO_AH
      <netinet/in.h>    IPPROTO_DSTOPTS
      <netinet/in.h>    IPPROTO_ESP
      <netinet/in.h>    IPPROTO_FRAGMENT
      <netinet/in.h>    IPPROTO_HOPOPTS
      <netinet/in.h>    IPPROTO_ICMPV6
      <netinet/in.h>    IPPROTO_IPV6
      <netinet/in.h>    IPPROTO_NONE
      <netinet/in.h>    IPPROTO_ROUTING
      <netinet/in.h>    IPV6_CHECKSUM
      <netinet/in.h>    IPV6_DONTFRAG
      <netinet/in.h>    IPV6_DSTOPTS
      <netinet/in.h>    IPV6_HOPLIMIT
      <netinet/in.h>    IPV6_HOPOPTS

      <netinet/in.h>    IPV6_NEXTHOP
      <netinet/in.h>    IPV6_PATHMTU
      <netinet/in.h>    IPV6_PKTINFO
      <netinet/in.h>    IPV6_RECVDSTOPTS
      <netinet/in.h>    IPV6_RECVHOPLIMIT
      <netinet/in.h>    IPV6_RECVHOPOPTS
      <netinet/in.h>    IPV6_RECVPKTINFO
      <netinet/in.h>    IPV6_RECVRTHDR
      <netinet/in.h>    IPV6_RECVTCLASS
      <netinet/in.h>    IPV6_RTHDR
      <netinet/in.h>    IPV6_RTHDRDSTOPTS
      <netinet/in.h>    IPV6_RTHDR_TYPE_0
      <netinet/in.h>    IPV6_RECVPATHMTU
      <netinet/in.h>    IPV6_TCLASS
      <netinet/in.h>    IPV6_USE_MIN_MTU
      <netinet/in.h>    struct in6_pktinfo{};
      <netinet/in.h>    struct ip6_mtuinfo{};

      <netinet/ip6.h>   IP6F_MORE_FRAG
      <netinet/ip6.h>   IP6F_OFF_MASK
      <netinet/ip6.h>   IP6F_RESERVED_MASK
      <netinet/ip6.h>   IP6OPT_JUMBO
      <netinet/ip6.h>   IP6OPT_JUMBO_LEN



Stevens, et al.              Informational                     [Page 54]

RFC 3542             Advanced Sockets API for IPv6              May 2003


      <netinet/ip6.h>   IP6OPT_MUTABLE
      <netinet/ip6.h>   IP6OPT_NSAP_ADDR
      <netinet/ip6.h>   IP6OPT_PAD1
      <netinet/ip6.h>   IP6OPT_PADN
      <netinet/ip6.h>   IP6OPT_ROUTER_ALERT
      <netinet/ip6.h>   IP6OPT_TUNNEL_LIMIT
      <netinet/ip6.h>   IP6OPT_TYPE_DISCARD
      <netinet/ip6.h>   IP6OPT_TYPE_FORCEICMP
      <netinet/ip6.h>   IP6OPT_TYPE_ICMP
      <netinet/ip6.h>   IP6OPT_TYPE_SKIP
      <netinet/ip6.h>   IP6_ALERT_AN
      <netinet/ip6.h>   IP6_ALERT_MLD
      <netinet/ip6.h>   IP6_ALERT_RSVP
      <netinet/ip6.h>   struct ip6_dest{};
      <netinet/ip6.h>   struct ip6_frag{};
      <netinet/ip6.h>   struct ip6_hbh{};
      <netinet/ip6.h>   struct ip6_hdr{};
      <netinet/ip6.h>   struct ip6_opt{};
      <netinet/ip6.h>   struct ip6_opt_jumbo{};
      <netinet/ip6.h>   struct ip6_opt_nsap{};
      <netinet/ip6.h>   struct ip6_opt_router{};
      <netinet/ip6.h>   struct ip6_opt_tunnel{};
      <netinet/ip6.h>   struct ip6_rthdr{};
      <netinet/ip6.h>   struct ip6_rthdr0{};

   The following list summarizes the function and macro prototypes
   discussed in this memo, sorted by header.

      <netinet/icmp6.h> void ICMP6_FILTER_SETBLOCK(int, struct
                                               icmp6_filter *);
      <netinet/icmp6.h> void
                        ICMP6_FILTER_SETBLOCKALL(struct icmp6_filter *);
      <netinet/icmp6.h> void
                        ICMP6_FILTER_SETPASS(int,
                                             struct icmp6_filter *);
      <netinet/icmp6.h> void
                        ICMP6_FILTER_SETPASSALL(struct icmp6_filter *);
      <netinet/icmp6.h> int  ICMP6_FILTER_WILLBLOCK(int,
                                           const struct icmp6_filter *);
      <netinet/icmp6.h> int  ICMP6_FILTER_WILLPASS(int,
                                           const struct icmp6_filter *);

      <netinet/in.h>    int IN6_ARE_ADDR_EQUAL(const struct in6_addr *,
                                           const struct in6_addr *);

      <netinet/in.h>    int inet6_opt_append(void *, socklen_t, int,
                                             uint8_t, socklen_t, uint_t,
                                             void **);



Stevens, et al.              Informational                     [Page 55]

RFC 3542             Advanced Sockets API for IPv6              May 2003


      <netinet/in.h>    int inet6_opt_get_val(void *, int, void *,
                                              socklen_t);
      <netinet/in.h>    int inet6_opt_find(void *, socklen_t,
                                           int, uint8_t ,
                                           socklen_t *, void **);
      <netinet/in.h>    int inet6_opt_finish(void *, socklen_t, int);
      <netinet/in.h>    int inet6_opt_init(void *, socklen_t);
      <netinet/in.h>    int inet6_opt_next(void *, socklen_t,
                                           int, uint8_t *,
                                           socklen_t *, void **);
      <netinet/in.h>    int inet6_opt_set_val(void *, int,
                                              void *, socklen_t);

      <netinet/in.h>    int inet6_rth_add(void *,
                                          const struct in6_addr *);
      <netinet/in.h>    struct in6_addr inet6_rth_getaddr(const void *,
                                                          int);
      <netinet/in.h>    void *inet6_rth_init(void *, socklen_t,
                                             int, int);
      <netinet/in.h>    int inet6_rth_reverse(const void *, void *);
      <netinet/in.h>    int inet6_rth_segments(const void *);
      <netinet/in.h>    soccklen_t inet6_rth_space(int, int);

      <netinet/ip6.h>   int  IP6OPT_TYPE(uint8_t);

      <sys/socket.h>    socklen_t CMSG_LEN(socklen_t);
      <sys/socket.h>    socklen_t CMSG_SPACE(socklen_t);

      <unistd.h>        int rresvport_af(int *, int);
      <unistd.h>        int rcmd_af(char **, unsigned short,
                                    const char *, const char *,
                                    const char *, int *, int);
      <unistd.h>        int rexec_af(char **, unsigned short,
                                     const char *, const char *,
                                     const char *, int *, int);

16.  Security Considerations

   The setting of certain Hop-by-Hop options and Destination options may
   be restricted to privileged processes.  Similarly some Hop-by-Hop
   options and Destination options may not be returned to non-privileged
   applications.

   The ability to specify an arbitrary source address using IPV6_PKTINFO
   must be prevented; at least for non-privileged processes.






Stevens, et al.              Informational                     [Page 56]

RFC 3542             Advanced Sockets API for IPv6              May 2003


17.  Changes from RFC 2292

   Significant changes that affect the compatibility to RFC 2292:

   -  Removed the IPV6_PKTOPTIONS socket option by allowing sticky
      options to be set with individual setsockopt() calls.

   -  Removed the ability to be able to specify Hop-by-Hop and
      Destination options using multiple ancillary data items.  The
      application, using the inet6_opt_xxx() routines (see below), is
      responsible for formatting the whole extension header.

   -  Removed the support for the loose/strict Routing header since that
      has been removed from the IPv6 specification.

   -  Loosened the constraints for jumbo payload option that this option
      was always hidden from applications.

   -  Disabled the use of the IPV6_HOPLIMIT sticky option.

   -  Removed ip6r0_addr field from the ip6_rthdr structure.

   -  Intentionally unspecified how to get received packet's information
      on TCP sockets.

   New features:

   -  Added IPV6_RTHDRDSTOPTS to specify a Destination Options header
      before the Routing header.

   -  Added separate IPV6_RECVxxx options to enable the receipt of the
      corresponding ancillary data items.

   -  Added inet6_rth_xxx() and inet6_opt_xxx() functions to deal with
      routing or IPv6 options headers.

   -  Added extensions of libraries for the "r" commands.

   -  Introduced additional IPv6 option definitions such as IP6OPT_PAD1.

   -  Added MLD and router renumbering definitions.

   -  Added MTU-related socket options and ancillary data items.

   -  Added options and ancillary data items to manipulate the traffic
      class field.





Stevens, et al.              Informational                     [Page 57]

RFC 3542             Advanced Sockets API for IPv6              May 2003


   -  Changed the name of ICMPv6 unreachable code 2 to be "beyond scope
      of source address."  ICMP6_DST_UNREACH_NOTNEIGHBOR was removed
      with this change.

   Clarifications:

   -  Added clarifications on extension headers ordering; for the
      sending side, assume the recommended ordering described in RFC
      2460.  For the receiving side, do not assume any ordering and pass
      all headers to the application in the received order.

   -  Added a summary about the interface selection rule.

   -  Clarified the ordering between IPV6_MULTICAST_IF and the
      IPV6_PKTINFO sticky option for multicast packets.

   -  Clarified how sticky options and the ICMPv6 filter are turned off
      and that getsockopt() of a sticky option returns what was set with
      setsockopt().

   -  Clarified that IPV6_NEXTHOP should be ignored for a multicast
      destination, that it should not contradict with the specified
      outgoing interface, and that the next hop should be a sockaddr_in6
      structure.

   -  Clarified corner cases of IPV6_CHECKSUM.

   -  Aligned with the POSIX standard.

   Editorial changes:

   -  Replaced MUST with must (since this is an informational document).

   -  Revised abstract to be more clear and concise, particularly
      concentrating on differences from RFC 2292.

   -  Made the URL of assigned numbers less specific so that it would be
      more robust for future changes.

   -  Updated the reference to the basic API.

   -  Added a reference to the latest POSIX standard.

   -  Moved general specifications of ancillary data and CMSG macros to
      the appendix.






Stevens, et al.              Informational                     [Page 58]

RFC 3542             Advanced Sockets API for IPv6              May 2003


18.  References

   [RFC-1981]    McCann, J., Deering, S. and J. Mogul, "Path MTU
                 Discovery for IP version 6", RFC 1981, August 1996.

   [RFC-2460]    Deering, S. and R. Hinden, "Internet Protocol, Version
                 6 (IPv6) Specification", RFC 2460, December 1998.

   [RFC-3493]    Gilligan, R., Thomson, S., Bound, J., McCann, J.  and
                 W. Stevens, "Basic Socket Interface Extensions for
                 IPv6", RFC 3493, March 2003.

   [POSIX]       IEEE Std. 1003.1-2001 Standard for Information
                 Technology -- Portable Operating System Interface
                 (POSIX). Open group Technical Standard: Base
                 Specifications, Issue 6, December 2001. ISO/IEC
                 9945:2002. http://www.opengroup.org/austin

   [TCPIPILLUST] Wright, G., Stevens, W., "TCP/IP Illustrated, Volume 2:
                 The Implementation", Addison Wesley, 1994.

19.  Acknowledgments

 



















Stevens, et al.              Informational                     [Page 76]

RFC 3542             Advanced Sockets API for IPv6              May 2003


24. Full Copyright Statement

   Copyright (C) The Internet Society (2003).  All Rights Reserved.

   This document and translations of it may be copied and furnished to
   others, and derivative works that comment on or otherwise explain it
   or assist in its implementation may be prepared, copied, published
   and distributed, in whole or in part, without restriction of any
   kind, provided that the above copyright notice and this paragraph are
   included on all such copies and derivative works.  However, this
   document itself may not be modified in any way, such as by removing
   the copyright notice or references to the Internet Society or other
   Internet organizations, except as needed for the purpose of
   developing Internet standards in which case the procedures for
   copyrights defined in the Internet Standards process must be
   followed, or as required to translate it into languages other than
   English.

   The limited permissions granted above are perpetual and will not be
   revoked by the Internet Society or its successors or assigns.

   This document and the information contained herein is provided on an
   "AS IS" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING
   TASK FORCE DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING
   BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION
   HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF
   MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.

Acknowledgement

   Funding for the RFC Editor function is currently provided by the
   Internet Society.




Acknowledgement

   Funding for the RFC Editor function is currently provided by the
   Internet Society.




Acknowledgement

   Funding for the RFC Editor function is currently provided by the
   Internet Society.




Acknowledgement

   Funding for the RFC Editor function is currently provided by the
   Internet Society.


Acknowledgement

   Funding for the RFC Editor function is currently provided by the
   Internet Society.

Acknowledgement

   Funding for the RFC Editor function is currently provided by the
   Internet Society.

Acknowledgement

   Funding for the RFC Editor function is currently provided by the
   Internet Society.




Acknowledgement

   Funding for the RFC Editor function is currently provided by the
   Internet Society.

Acknowledgement

   Funding for the RFC Editor function is currently provided by the
   Internet Society.




Acknowledgement

   Funding for the RFC Editor function is currently provided by the
   Internet Society.




Acknowledgement

   Funding for the RFC Editor function is currently provided by the
   Internet Society.




Acknowledgement

   Funding for the RFC Editor function is currently provided by the
   Internet Society.




Acknowledgement

   Funding for the RFC Editor function is currently provided by the
   Internet Society.




Acknowledgement

   Funding for the RFC Editor function is currently provided by the
   Internet Society.




Acknowledgement

   Funding for the RFC Editor function is currently provided by the
   Internet Society.




Acknowledgement

   Funding for the RFC Editor function is currently provided by the
   Internet Society.




Acknowledgement

   Funding for the RFC Editor function is currently provided by the
   Internet Society.




Acknowledgement

   Funding for the RFC Editor function is currently provided by the
   Internet Society.



Acknowledgement

   Funding for the RFC Editor function is currently provided by the
   Internet Society.




Acknowledgement

   Funding for the RFC Editor function is currently provided by the
   Internet Society.




Acknowledgement

   Funding for the RFC Editor function is currently provided by the
   Internet Society.




Acknowledgement

   Funding for the RFC Editor function is currently provided by the
   Internet Society.




Acknowledgement

   Funding for the RFC Editor function is currently provided by the
   Internet Society.




Acknowledgement

   Funding for the RFC Editor function is currently provided by the
   Internet Society.




Stevens, et al.              Informational                     [Page 49]

RFC 3542             Advanced Sockets API for IPv6              May 2003


   For example, when an application sends a UDP datagram with a control
   data buffer containing ancillary data objects in the following order:

      an object with cmsg_type set to IPV6_DSTOPTS
      an object with cmsg_type set to IPV6_RTHDRDSTOPTS
      an object with cmsg_type set to IPV6_HOPOPTS

   and the sending socket does not have any sticky options, then the
   outgoing packet would be constructed as follows:

      The IPv6 header
      A Hop-by-Hop options header
      A Destination options header
      A UDP header and UDP data

   where the destination options header corresponds to the ancillary
   data object with the type IPV6_DSTOPTS.

   Note that the constraints above do not necessarily mean that the
   outgoing packet sent on the wire always follows the header ordering
   specified in this API document.  The kernel may insert additional
   headers that break the ordering as a result.  For example, if the
   kernel supports Mobile IPv6, an additional destination options header
   may be inserted before an authentication header, even without a
   routing header.

   This API does not provide access to any other extension headers than
   the supported three types of headers.  In particular, no information
   is provided about the IP security headers on an incoming packet, nor
   can be specified for an outgoing packet.  This API is for
   applications that do not care about the existence of IP security
   headers.

13.  IPv6-Specific Options with IPv4-Mapped IPv6 Addresses

   The various socket options and ancillary data specifications defined
   in this document apply only to true IPv6 sockets.  It is possible to
   create an IPv6 socket that actually sends and receives IPv4 packets,
   using IPv4-mapped IPv6 addresses, but the mapping of the options
   defined in this document to an IPv4 datagram is beyond the scope of
   this document.

   In general, attempting to specify an IPv6-only option, such as the
   Hop-by-Hop options, Destination options, or Routing header on an IPv6
   socket that is using IPv4-mapped IPv6 addresses, will probably result
   in an error.  Some implementations, however, may provide access to





Stevens, et al.              Informational                     [Page 50]

RFC 3542             Advanced Sockets API for IPv6              May 2003


   the packet information (source/destination address, send/receive
   interface, and hop limit) on an IPv6 socket that is using IPv4-mapped
   IPv6 addresses.

14.  Extended interfaces for rresvport, rcmd and rexec

   Library functions that support the "r" commands hide the creation of
   a socket and the name resolution procedure from an application.  When
   the libraries return an AF_INET6 socket to an application that do not
   support the address family, the application may encounter an
   unexpected result when, e.g., calling getpeername() for the socket.
   In order to support AF_INET6 sockets for the "r" commands while
   keeping backward compatibility, this section defines some extensions
   to the libraries.

14.1.  rresvport_af

   The rresvport() function is used by the rcmd() function, and this
   function is in turn called by many of the "r" commands such as
   rlogin.  While new applications are not being written to use the
   rcmd() function, legacy applications such as rlogin will continue to
   use it and these will be ported to IPv6.

   rresvport() creates an IPv4/TCP socket and binds a "reserved port" to
   the socket.  Instead of defining an IPv6 version of this function we
   define a new function that takes an address family as its argument.

      #include <unistd.h>

      int  rresvport_af(int *port, int family);

   This function behaves the same as the existing rresvport() function,
   but instead of creating an AF_INET TCP socket, it can also create an
   AF_INET6 TCP socket.  The family argument is either AF_INET or
   AF_INET6, and a new error return is EAFNOSUPPORT if the address
   family is not supported.

   (Note: There is little consensus on which header defines the
   rresvport() and rcmd() function prototypes.  4.4BSD defines it in
   <unistd.h>, others in <netdb.h>, and others don't define the function
   prototypes at all.)

14.2.  rcmd_af

   The existing rcmd() function can not transparently use AF_INET6
   sockets since an application would not be prepared to handle AF_INET6
   addresses returned by e.g., getpeername() on the file descriptor
   created by rcmd().  Thus a new function is needed.



Stevens, et al.              Informational                     [Page 51]

RFC 3542             Advanced Sockets API for IPv6              May 2003


      int rcmd_af(char **ahost, unsigned short rport,
                  const char *locuser, const char *remuser,
                  const char *cmd, int *fd2p, int af)

   This function behaves the same as the existing rcmd() function, but
   instead of creating an AF_INET TCP socket, it can also create an
   AF_INET6 TCP socket.  The family argument is AF_INET, AF_INET6, or
   AF_UNSPEC.  When either AF_INET or AF_INET6 is specified, this
   function will create a socket of the specified address family.  When
   AF_UNSPEC is specified, it will try all possible address families
   until a connection can be established, and will return the associated
   socket of the connection.  A new error EAFNOSUPPORT will be returned
   if the address family is not supported.

14.3.  rexec_af

   The existing rexec() function can not transparently use AF_INET6
   sockets since an application would not be prepared to handle AF_INET6
   addresses returned by e.g., getpeername() on the file descriptor
   created by rexec().  Thus a new function is needed.

      int rexec_af(char **ahost, unsigned short rport, const char *name,
                   const char *pass, const char *cmd, int *fd2p, int af)

   This function behaves the same as the existing rexec() function, but
   instead of creating an AF_INET TCP socket, it can also create an
   AF_INET6 TCP socket.  The family argument is AF_INET, AF_INET6, or
   AF_UNSPEC.  When either AF_INET or AF_INET6 is specified, this
   function will create a socket of the specified address family.  When
   AF_UNSPEC is specified, it will try all possible address families
   until a connection can be established, and will return the associated
   socket of the connection.  A new error EAFNOSUPPORT will be returned
   if the address family is not supported.

15.  Summary of New Definitions

   The following list summarizes the constants and structure,
   definitions discussed in this memo, sorted by header.

      <netinet/icmp6.h> ICMP6_DST_UNREACH
      <netinet/icmp6.h> ICMP6_DST_UNREACH_ADDR
      <netinet/icmp6.h> ICMP6_DST_UNREACH_ADMIN
      <netinet/icmp6.h> ICMP6_DST_UNREACH_BEYONDSCOPE
      <netinet/icmp6.h> ICMP6_DST_UNREACH_NOPORT
      <netinet/icmp6.h> ICMP6_DST_UNREACH_NOROUTE
      <netinet/icmp6.h> ICMP6_ECHO_REPLY
      <netinet/icmp6.h> ICMP6_ECHO_REQUEST
      <netinet/icmp6.h> ICMP6_INFOMSG_MASK



Stevens, et al.              Informational                     [Page 52]

RFC 3542             Advanced Sockets API for IPv6              May 2003


      <netinet/icmp6.h> ICMP6_PACKET_TOO_BIG
      <netinet/icmp6.h> ICMP6_PARAMPROB_HEADER
      <netinet/icmp6.h> ICMP6_PARAMPROB_NEXTHEADER
      <netinet/icmp6.h> ICMP6_PARAMPROB_OPTION
      <netinet/icmp6.h> ICMP6_PARAM_PROB
      <netinet/icmp6.h> ICMP6_ROUTER_RENUMBERING
      <netinet/icmp6.h> ICMP6_RR_FLAGS_FORCEAPPLY
      <netinet/icmp6.h> ICMP6_RR_FLAGS_PREVDONE
      <netinet/icmp6.h> ICMP6_RR_FLAGS_REQRESULT
      <netinet/icmp6.h> ICMP6_RR_FLAGS_SPECSITE
      <netinet/icmp6.h> ICMP6_RR_FLAGS_TEST
      <netinet/icmp6.h> ICMP6_RR_PCOUSE_FLAGS_DECRPLTIME
      <netinet/icmp6.h> ICMP6_RR_PCOUSE_FLAGS_DECRVLTIME
      <netinet/icmp6.h> ICMP6_RR_PCOUSE_RAFLAGS_AUTO
      <netinet/icmp6.h> ICMP6_RR_PCOUSE_RAFLAGS_ONLINK
      <netinet/icmp6.h> ICMP6_RR_RESULT_FLAGS_FORBIDDEN
      <netinet/icmp6.h> ICMP6_RR_RESULT_FLAGS_OOB
      <netinet/icmp6.h> ICMP6_TIME_EXCEEDED
      <netinet/icmp6.h> ICMP6_TIME_EXCEED_REASSEMBLY
      <netinet/icmp6.h> ICMP6_TIME_EXCEED_TRANSIT
      <netinet/icmp6.h> MLD_LISTENER_QUERY
      <netinet/icmp6.h> MLD_LISTENER_REDUCTION
      <netinet/icmp6.h> MLD_LISTENER_REPORT
      <netinet/icmp6.h> ND_NA_FLAG_OVERRIDE
      <netinet/icmp6.h> ND_NA_FLAG_ROUTER
      <netinet/icmp6.h> ND_NA_FLAG_SOLICITED
      <netinet/icmp6.h> ND_NEIGHBOR_ADVERT
      <netinet/icmp6.h> ND_NEIGHBOR_SOLICIT
      <netinet/icmp6.h> ND_OPT_MTU
      <netinet/icmp6.h> ND_OPT_PI_FLAG_AUTO
      <netinet/icmp6.h> ND_OPT_PI_FLAG_ONLINK
      <netinet/icmp6.h> ND_OPT_PREFIX_INFORMATION
      <netinet/icmp6.h> ND_OPT_REDIRECTED_HEADER
      <netinet/icmp6.h> ND_OPT_SOURCE_LINKADDR
      <netinet/icmp6.h> ND_OPT_TARGET_LINKADDR
      <netinet/icmp6.h> ND_RA_FLAG_MANAGED
      <netinet/icmp6.h> ND_RA_FLAG_OTHER
      <netinet/icmp6.h> ND_REDIRECT
      <netinet/icmp6.h> ND_ROUTER_ADVERT
      <netinet/icmp6.h> ND_ROUTER_SOLICIT

      <netinet/icmp6.h> struct icmp6_filter{};
      <netinet/icmp6.h> struct icmp6_hdr{};
      <netinet/icmp6.h> struct icmp6_router_renum{};
      <netinet/icmp6.h> struct mld_hdr{};
      <netinet/icmp6.h> struct nd_neighbor_advert{};
      <netinet/icmp6.h> struct nd_neighbor_solicit{};
      <netinet/icmp6.h> struct nd_opt_hdr{};



Stevens, et al.              Informational                     [Page 53]

RFC 3542             Advanced Sockets API for IPv6              May 2003


      <netinet/icmp6.h> struct nd_opt_mtu{};
      <netinet/icmp6.h> struct nd_opt_prefix_info{};
      <netinet/icmp6.h> struct nd_opt_rd_hdr{};
      <netinet/icmp6.h> struct nd_redirect{};
      <netinet/icmp6.h> struct nd_router_advert{};
      <netinet/icmp6.h> struct nd_router_solicit{};
      <netinet/icmp6.h> struct rr_pco_match{};
      <netinet/icmp6.h> struct rr_pco_use{};
      <netinet/icmp6.h> struct rr_result{};

      <netinet/in.h>    IPPROTO_AH
      <netinet/in.h>    IPPROTO_DSTOPTS
      <netinet/in.h>    IPPROTO_ESP
      <netinet/in.h>    IPPROTO_FRAGMENT
      <netinet/in.h>    IPPROTO_HOPOPTS
      <netinet/in.h>    IPPROTO_ICMPV6
      <netinet/in.h>    IPPROTO_IPV6
      <netinet/in.h>    IPPROTO_NONE
      <netinet/in.h>    IPPROTO_ROUTING
      <netinet/in.h>    IPV6_CHECKSUM
      <netinet/in.h>    IPV6_DONTFRAG
      <netinet/in.h>    IPV6_DSTOPTS
      <netinet/in.h>    IPV6_HOPLIMIT
      <netinet/in.h>    IPV6_HOPOPTS

      <netinet/in.h>    IPV6_NEXTHOP
      <netinet/in.h>    IPV6_PATHMTU
      <netinet/in.h>    IPV6_PKTINFO
      <netinet/in.h>    IPV6_RECVDSTOPTS
      <netinet/in.h>    IPV6_RECVHOPLIMIT
      <netinet/in.h>    IPV6_RECVHOPOPTS
      <netinet/in.h>    IPV6_RECVPKTINFO
      <netinet/in.h>    IPV6_RECVRTHDR
      <netinet/in.h>    IPV6_RECVTCLASS
      <netinet/in.h>    IPV6_RTHDR
      <netinet/in.h>    IPV6_RTHDRDSTOPTS
      <netinet/in.h>    IPV6_RTHDR_TYPE_0
      <netinet/in.h>    IPV6_RECVPATHMTU
      <netinet/in.h>    IPV6_TCLASS
      <netinet/in.h>    IPV6_USE_MIN_MTU
      <netinet/in.h>    struct in6_pktinfo{};
      <netinet/in.h>    struct ip6_mtuinfo{};

      <netinet/ip6.h>   IP6F_MORE_FRAG
      <netinet/ip6.h>   IP6F_OFF_MASK
      <netinet/ip6.h>   IP6F_RESERVED_MASK
      <netinet/ip6.h>   IP6OPT_JUMBO
      <netinet/ip6.h>   IP6OPT_JUMBO_LEN



Stevens, et al.              Informational                     [Page 54]

RFC 3542             Advanced Sockets API for IPv6              May 2003


      <netinet/ip6.h>   IP6OPT_MUTABLE
      <netinet/ip6.h>   IP6OPT_NSAP_ADDR
      <netinet/ip6.h>   IP6OPT_PAD1
      <netinet/ip6.h>   IP6OPT_PADN
      <netinet/ip6.h>   IP6OPT_ROUTER_ALERT
      <netinet/ip6.h>   IP6OPT_TUNNEL_LIMIT
      <netinet/ip6.h>   IP6OPT_TYPE_DISCARD
      <netinet/ip6.h>   IP6OPT_TYPE_FORCEICMP
      <netinet/ip6.h>   IP6OPT_TYPE_ICMP
      <netinet/ip6.h>   IP6OPT_TYPE_SKIP
      <netinet/ip6.h>   IP6_ALERT_AN
      <netinet/ip6.h>   IP6_ALERT_MLD
      <netinet/ip6.h>   IP6_ALERT_RSVP
      <netinet/ip6.h>   struct ip6_dest{};
      <netinet/ip6.h>   struct ip6_frag{};
      <netinet/ip6.h>   struct ip6_hbh{};
      <netinet/ip6.h>   struct ip6_hdr{};
      <netinet/ip6.h>   struct ip6_opt{};
      <netinet/ip6.h>   struct ip6_opt_jumbo{};
      <netinet/ip6.h>   struct ip6_opt_nsap{};
      <netinet/ip6.h>   struct ip6_opt_router{};
      <netinet/ip6.h>   struct ip6_opt_tunnel{};
      <netinet/ip6.h>   struct ip6_rthdr{};
      <netinet/ip6.h>   struct ip6_rthdr0{};

   The following list summarizes the function and macro prototypes
   discussed in this memo, sorted by header.

      <netinet/icmp6.h> void ICMP6_FILTER_SETBLOCK(int, struct
                                               icmp6_filter *);
      <netinet/icmp6.h> void
                        ICMP6_FILTER_SETBLOCKALL(struct icmp6_filter *);
      <netinet/icmp6.h> void
                        ICMP6_FILTER_SETPASS(int,
                                             struct icmp6_filter *);
      <netinet/icmp6.h> void
                        ICMP6_FILTER_SETPASSALL(struct icmp6_filter *);
      <netinet/icmp6.h> int  ICMP6_FILTER_WILLBLOCK(int,
                                           const struct icmp6_filter *);
      <netinet/icmp6.h> int  ICMP6_FILTER_WILLPASS(int,
                                           const struct icmp6_filter *);

      <netinet/in.h>    int IN6_ARE_ADDR_EQUAL(const struct in6_addr *,
                                           const struct in6_addr *);

      <netinet/in.h>    int inet6_opt_append(void *, socklen_t, int,
                                             uint8_t, socklen_t, uint_t,
                                             void **);



Stevens, et al.              Informational                     [Page 55]

RFC 3542             Advanced Sockets API for IPv6              May 2003


      <netinet/in.h>    int inet6_opt_get_val(void *, int, void *,
                                              socklen_t);
      <netinet/in.h>    int inet6_opt_find(void *, socklen_t,
                                           int, uint8_t ,
                                           socklen_t *, void **);
      <netinet/in.h>    int inet6_opt_finish(void *, socklen_t, int);
      <netinet/in.h>    int inet6_opt_init(void *, socklen_t);
      <netinet/in.h>    int inet6_opt_next(void *, socklen_t,
                                           int, uint8_t *,
                                           socklen_t *, void **);
      <netinet/in.h>    int inet6_opt_set_val(void *, int,
                                              void *, socklen_t);

      <netinet/in.h>    int inet6_rth_add(void *,
                                          const struct in6_addr *);
      <netinet/in.h>    struct in6_addr inet6_rth_getaddr(const void *,
                                                          int);
      <netinet/in.h>    void *inet6_rth_init(void *, socklen_t,
                                             int, int);
      <netinet/in.h>    int inet6_rth_reverse(const void *, void *);
      <netinet/in.h>    int inet6_rth_segments(const void *);
      <netinet/in.h>    soccklen_t inet6_rth_space(int, int);

      <netinet/ip6.h>   int  IP6OPT_TYPE(uint8_t);

      <sys/socket.h>    socklen_t CMSG_LEN(socklen_t);
      <sys/socket.h>    socklen_t CMSG_SPACE(socklen_t);

      <unistd.h>        int rresvport_af(int *, int);
      <unistd.h>        int rcmd_af(char **, unsigned short,
                                    const char *, const char *,
                                    const char *, int *, int);
      <unistd.h>        int rexec_af(char **, unsigned short,
                                     const char *, const char *,
                                     const char *, int *, int);

16.  Security Considerations

   The setting of certain Hop-by-Hop options and Destination options may
   be restricted to privileged processes.  Similarly some Hop-by-Hop
   options and Destination options may not be returned to non-privileged
   applications.

   The ability to specify an arbitrary source address using IPV6_PKTINFO
   must be prevented; at least for non-privileged processes.






Stevens, et al.              Informational                     [Page 56]

RFC 3542             Advanced Sockets API for IPv6              May 2003


17.  Changes from RFC 2292

   Significant changes that affect the compatibility to RFC 2292:

   -  Removed the IPV6_PKTOPTIONS socket option by allowing sticky
      options to be set with individual setsockopt() calls.

   -  Removed the ability to be able to specify Hop-by-Hop and
      Destination options using multiple ancillary data items.  The
      application, using the inet6_opt_xxx() routines (see below), is
      responsible for formatting the whole extension header.

   -  Removed the support for the loose/strict Routing header since that
      has been removed from the IPv6 specification.

   -  Loosened the constraints for jumbo payload option that this option
      was always hidden from applications.

   -  Disabled the use of the IPV6_HOPLIMIT sticky option.

   -  Removed ip6r0_addr field from the ip6_rthdr structure.

   -  Intentionally unspecified how to get received packet's information
      on TCP sockets.

   New features:

   -  Added IPV6_RTHDRDSTOPTS to specify a Destination Options header
      before the Routing header.

   -  Added separate IPV6_RECVxxx options to enable the receipt of the
      corresponding ancillary data items.

   -  Added inet6_rth_xxx() and inet6_opt_xxx() functions to deal with
      routing or IPv6 options headers.

   -  Added extensions of libraries for the "r" commands.

   -  Introduced additional IPv6 option definitions such as IP6OPT_PAD1.

   -  Added MLD and router renumbering definitions.

   -  Added MTU-related socket options and ancillary data items.

   -  Added options and ancillary data items to manipulate the traffic
      class field.





Stevens, et al.              Informational                     [Page 57]

RFC 3542             Advanced Sockets API for IPv6              May 2003


   -  Changed the name of ICMPv6 unreachable code 2 to be "beyond scope
      of source address."  ICMP6_DST_UNREACH_NOTNEIGHBOR was removed
      with this change.

   Clarifications:

   -  Added clarifications on extension headers ordering; for the
      sending side, assume the recommended ordering described in RFC
      2460.  For the receiving side, do not assume any ordering and pass
      all headers to the application in the received order.

   -  Added a summary about the interface selection rule.

   -  Clarified the ordering between IPV6_MULTICAST_IF and the
      IPV6_PKTINFO sticky option for multicast packets.

   -  Clarified how sticky options and the ICMPv6 filter are turned off
      and that getsockopt() of a sticky option returns what was set with
      setsockopt().

   -  Clarified that IPV6_NEXTHOP should be ignored for a multicast
      destination, that it should not contradict with the specified
      outgoing interface, and that the next hop should be a sockaddr_in6
      structure.

   -  Clarified corner cases of IPV6_CHECKSUM.

   -  Aligned with the POSIX standard.

   Editorial changes:

   -  Replaced MUST with must (since this is an informational document).

   -  Revised abstract to be more clear and concise, particularly
      concentrating on differences from RFC 2292.

   -  Made the URL of assigned numbers less specific so that it would be
      more robust for future changes.

   -  Updated the reference to the basic API.

   -  Added a reference to the latest POSIX standard.

   -  Moved general specifications of ancillary data and CMSG macros to
      the appendix.






Stevens, et al.              Informational                     [Page 58]

RFC 3542             Advanced Sockets API for IPv6              May 2003


18.  References

   [RFC-1981]    McCann, J., Deering, S. and J. Mogul, "Path MTU
                 Discovery for IP version 6", RFC 1981, August 1996.

   [RFC-2460]    Deering, S. and R. Hinden, "Internet Protocol, Version
                 6 (IPv6) Specification", RFC 2460, December 1998.

   [RFC-3493]    Gilligan, R., Thomson, S., Bound, J., McCann, J.  and
                 W. Stevens, "Basic Socket Interface Extensions for
                 IPv6", RFC 3493, March 2003.

   [POSIX]       IEEE Std. 1003.1-2001 Standard for Information
                 Technology -- Portable Operating System Interface
                 (POSIX). Open group Technical Standard: Base
                 Specifications, Issue 6, December 2001. ISO/IEC
                 9945:2002. http://www.opengroup.org/austin

   [TCPIPILLUST] Wright, G., Stevens, W., "TCP/IP Illustrated, Volume 2:
                 The Implementation", Addison Wesley, 1994.

19.  Acknowledgments

 



















Stevens, et al.              Informational                     [Page 76]

RFC 3542             Advanced Sockets API for IPv6              May 2003


24. Full Copyright Statement

   Copyright (C) The Internet Society (2003).  All Rights Reserved.

   This document and translations of it may be copied and furnished to
   others, and derivative works that comment on or otherwise explain it
   or assist in its implementation may be prepared, copied, published
   and distributed, in whole or in part, without restriction of any
   kind, provided that the above copyright notice and this paragraph are
   included on all such copies and derivative works.  However, this
   document itself may not be modified in any way, such as by removing
   the copyright notice or references to the Internet Society or other
   Internet organizations, except as needed for the purpose of
   developing Internet standards in which case the procedures for
   copyrights defined in the Internet Standards process must be
   followed, or as required to translate it into languages other than
   English.

   The limited permissions granted above are perpetual and will not be
   revoked by the Internet Society or its successors or assigns.

   This document and the information contained herein is provided on an
   "AS IS" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING
   TASK FORCE DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING
   BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION
   HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF
   MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.

Acknowledgement

   Funding for the RFC Editor function is currently provided by the
   Internet Society.




Acknowledgement

   Funding for the RFC Editor function is currently provided by the
   Internet Society.




Acknowledgement

   Funding for the RFC Editor function is currently provided by the
   Internet Society.




Acknowledgement

   Funding for the RFC Editor function is currently provided by the
   Internet Society.


Acknowledgement

   Funding for the RFC Editor function is currently provided by the
   Internet Society.

Acknowledgement

   Funding for the RFC Editor function is currently provided by the
   Internet Society.

Acknowledgement

   Funding for the RFC Editor function is currently provided by the
   Internet Society.




Acknowledgement

   Funding for the RFC Editor function is currently provided by the
   Internet Society.

Acknowledgement

   Funding for the RFC Editor function is currently provided by the
   Internet Society.




Acknowledgement

   Funding for the RFC Editor function is currently provided by the
   Internet Society.




Acknowledgement

   Funding for the RFC Editor function is currently provided by the
   Internet Society.




Acknowledgement

   Funding for the RFC Editor function is currently provided by the
   Internet Society.




Acknowledgement

   Funding for the RFC Editor function is currently provided by the
   Internet Society.




Acknowledgement

   Funding for the RFC Editor function is currently provided by the
   Internet Society.




Acknowledgement

   Funding for the RFC Editor function is currently provided by the
   Internet Society.




Acknowledgement

   Funding for the RFC Editor function is currently provided by the
   Internet Society.




Acknowledgement

   Funding for the RFC Editor function is currently provided by the
   Internet Society.




Acknowledgement

   Funding for the RFC Editor function is currently provided by the
   Internet Society.



Acknowledgement

   Funding for the RFC Editor function is currently provided by the
   Internet Society.




Acknowledgement

   Funding for the RFC Editor function is currently provided by the
   Internet Society.




Acknowledgement

   Funding for the RFC Editor function is currently provided by the
   Internet Society.




Acknowledgement

   Funding for the RFC Editor function is currently provided by the
   Internet Society.




Acknowledgement

   Funding for the RFC Editor function is currently provided by the
   Internet Society.




Acknowledgement

   Funding for the RFC Editor function is currently provided by the
   Internet Society.


Stevens, et al.              Informational                     [Page ]

21